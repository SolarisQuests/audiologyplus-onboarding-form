{"ast":null,"code":"/**\n * Module dependencies.\n */\n\nvar types = require('ast-types');\nvar esprima = require('esprima');\nvar escodegen = require('escodegen');\n\n/**\n * Helper functions.\n */\n\nvar n = types.namedTypes;\nvar b = types.builders;\n\n/**\n * Module exports.\n */\n\nmodule.exports = degenerator;\n\n/**\n * Turns sync JavaScript code into an JavaScript with async Generator Functions.\n *\n * @param {String} jsStr JavaScript string to convert\n * @param {Array} names Array of function names to add `yield` operators to\n * @return {String} Converted JavaScript string with Generator functions injected\n * @api public\n */\n\nfunction degenerator(jsStr, names) {\n  if (!Array.isArray(names)) {\n    throw new TypeError('an array of async function \"names\" is required');\n  }\n  var ast = esprima.parse(jsStr);\n\n  // duplicate the `names` array since it's rude to augment the user-provided\n  // array\n  names = names.slice(0);\n\n  // first pass is to find the `function` nodes and turn them into `function *`\n  // generator functions. We also add the names of the functions to the `names`\n  // array\n  types.visit(ast, {\n    visitFunction: function (path) {\n      if (path.node.id) {\n        // got a \"function\" expression/statement,\n        // convert it into a \"generator function\"\n        path.node.generator = true;\n\n        // add function name to `names` array\n        names.push(path.node.id.name);\n      }\n      this.traverse(path);\n    }\n  });\n\n  // second pass is for adding `yield` statements to any function\n  // invocations that match the given `names` array.\n  types.visit(ast, {\n    visitCallExpression: function (path) {\n      if (checkNames(path.node, names)) {\n        // a \"function invocation\" expression,\n        // we need to inject a `YieldExpression`\n        var name = path.name;\n        var parent = path.parent.node;\n        var delegate = false;\n        var expr = b.yieldExpression(path.node, delegate);\n        if (parent['arguments']) {\n          // parent is a `CallExpression` type\n          parent['arguments'][name] = expr;\n        } else {\n          parent[name] = expr;\n        }\n      }\n      this.traverse(path);\n    }\n  });\n  return escodegen.generate(ast);\n}\n\n/**\n * Returns `true` if `node` has a matching name to one of the entries in the\n * `names` array.\n *\n * @param {types.Node} node\n * @param {Array} names Array of function names to return true for\n * @return {Boolean}\n * @api private\n */\n\nfunction checkNames(node, names) {\n  var name;\n  var callee = node.callee;\n  if ('Identifier' == callee.type) {\n    name = callee.name;\n  } else if ('MemberExpression' == callee.type) {\n    name = callee.object.name + '.' + (callee.property.name || callee.property.raw);\n  } else if ('FunctionExpression' == callee.type) {\n    if (callee.id) {\n      name = callee.id.name;\n    } else {\n      return false;\n    }\n  } else {\n    throw new Error('don\\'t know how to get name for: ' + callee.type);\n  }\n\n  // now that we have the `name`, check if any entries match in the `names` array\n  var n;\n  for (var i = 0; i < names.length; i++) {\n    n = names[i];\n    if (n.test) {\n      // regexp\n      if (n.test(name)) return true;\n    } else {\n      if (name == n) return true;\n    }\n  }\n  return false;\n}","map":{"version":3,"names":["types","require","esprima","escodegen","n","namedTypes","b","builders","module","exports","degenerator","jsStr","names","Array","isArray","TypeError","ast","parse","slice","visit","visitFunction","path","node","id","generator","push","name","traverse","visitCallExpression","checkNames","parent","delegate","expr","yieldExpression","generate","callee","type","object","property","raw","Error","i","length","test"],"sources":["/Users/sathyamurthyt/Documents/Ai-forms/form-wizard/node_modules/degenerator/index.js"],"sourcesContent":["\n/**\n * Module dependencies.\n */\n\nvar types = require('ast-types');\nvar esprima = require('esprima');\nvar escodegen = require('escodegen');\n\n/**\n * Helper functions.\n */\n\nvar n = types.namedTypes;\nvar b = types.builders;\n\n/**\n * Module exports.\n */\n\nmodule.exports = degenerator;\n\n/**\n * Turns sync JavaScript code into an JavaScript with async Generator Functions.\n *\n * @param {String} jsStr JavaScript string to convert\n * @param {Array} names Array of function names to add `yield` operators to\n * @return {String} Converted JavaScript string with Generator functions injected\n * @api public\n */\n\nfunction degenerator (jsStr, names) {\n  if (!Array.isArray(names)) {\n    throw new TypeError('an array of async function \"names\" is required');\n  }\n\n  var ast = esprima.parse(jsStr);\n\n  // duplicate the `names` array since it's rude to augment the user-provided\n  // array\n  names = names.slice(0);\n\n\n  // first pass is to find the `function` nodes and turn them into `function *`\n  // generator functions. We also add the names of the functions to the `names`\n  // array\n  types.visit(ast, {\n    visitFunction: function(path) {\n      if (path.node.id) {\n        // got a \"function\" expression/statement,\n        // convert it into a \"generator function\"\n        path.node.generator = true;\n\n        // add function name to `names` array\n        names.push(path.node.id.name);\n      }\n\n      this.traverse(path);\n    }\n  });\n\n  // second pass is for adding `yield` statements to any function\n  // invocations that match the given `names` array.\n  types.visit(ast, {\n    visitCallExpression: function(path) {\n      if (checkNames(path.node, names)) {\n        // a \"function invocation\" expression,\n        // we need to inject a `YieldExpression`\n        var name = path.name;\n        var parent = path.parent.node;\n\n        var delegate = false;\n        var expr = b.yieldExpression(path.node, delegate);\n        if (parent['arguments']) {\n          // parent is a `CallExpression` type\n          parent['arguments'][name] = expr;\n        } else {\n          parent[name] = expr;\n        }\n      }\n\n      this.traverse(path);\n    }\n  });\n\n  return escodegen.generate(ast);\n}\n\n/**\n * Returns `true` if `node` has a matching name to one of the entries in the\n * `names` array.\n *\n * @param {types.Node} node\n * @param {Array} names Array of function names to return true for\n * @return {Boolean}\n * @api private\n */\n\nfunction checkNames (node, names) {\n  var name;\n  var callee = node.callee;\n  if ('Identifier' == callee.type) {\n    name = callee.name;\n  } else if ('MemberExpression' == callee.type) {\n    name = callee.object.name + '.' + (callee.property.name || callee.property.raw);\n  } else if ('FunctionExpression' == callee.type) {\n    if (callee.id) {\n      name = callee.id.name;\n    } else {\n      return false;\n    }\n  } else {\n    throw new Error('don\\'t know how to get name for: ' + callee.type);\n  }\n\n  // now that we have the `name`, check if any entries match in the `names` array\n  var n;\n  for (var i = 0; i < names.length; i++) {\n    n = names[i];\n    if (n.test) {\n      // regexp\n      if (n.test(name)) return true;\n    } else {\n      if (name == n) return true;\n    }\n  }\n\n  return false;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}