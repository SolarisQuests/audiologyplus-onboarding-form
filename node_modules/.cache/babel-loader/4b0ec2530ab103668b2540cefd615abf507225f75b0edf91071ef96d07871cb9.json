{"ast":null,"code":"/**\n * Module dependencies.\n */\n\nvar FTP = require('ftp');\nvar path = require('path');\nvar NotFoundError = require('./notfound');\nvar NotModifiedError = require('./notmodified');\nvar debug = require('debug')('get-uri:ftp');\n\n/**\n * Module exports.\n */\n\nmodule.exports = get;\n\n/**\n * Returns a Readable stream from an \"ftp:\" URI.\n *\n * @api protected\n */\n\nfunction get(parsed, opts, fn) {\n  var cache = opts.cache;\n  var client = new FTP();\n  var filepath = parsed.pathname;\n  var lastModified;\n  client.once('error', onerror);\n  client.once('ready', onready);\n  client.once('greeting', ongreeting);\n  function onready() {\n    // first we have to figure out the Last Modified date.\n    // try the MDTM command first, which is an optional extension command.\n    client.lastMod(filepath, onlastmod);\n  }\n  function ongreeting(greeting) {\n    debug('FTP greeting: %o', greeting);\n  }\n  function onerror(err) {\n    client.end();\n    fn(err);\n  }\n  function onfile(err, stream) {\n    if (err) return onerror(err);\n    stream.once('end', onend);\n    stream.lastModified = lastModified;\n    fn(null, stream);\n  }\n  function onend() {\n    // close the FTP client socket connection\n    client.end();\n  }\n  function getFile() {\n    client.get(filepath, onfile);\n  }\n  function onlastmod(err, lastmod) {\n    // handle the \"file not found\" error code\n    if (err) {\n      if (550 == err.code) {\n        onerror(new NotFoundError());\n      }\n      // any other error then we'll try the LIST command instead\n    }\n    if (lastmod) {\n      setLastMod(lastmod);\n    } else {\n      // try to get the last modified date via the LIST command (uses\n      // more bandwidth, but is more compatible with older FTP servers\n      var dir = path.dirname(filepath);\n      client.list(dir, onlist);\n    }\n  }\n  function setLastMod(lastmod) {\n    lastModified = lastmod;\n    if (cache && isNotModified()) {\n      // file is the same as in the \"cache\", return a not modified error\n      onerror(new NotModifiedError());\n    } else {\n      // XXX: a small timeout seemed necessary otherwise FTP servers\n      // were returning empty sockets for the file occasionally\n      setTimeout(client.get.bind(client, filepath, onfile), 10);\n    }\n  }\n  function onlist(err, list) {\n    if (err) return onerror(err);\n    var name = path.basename(filepath);\n\n    // attempt to find the \"entry\" with a matching \"name\"\n    var entry;\n    for (var i = 0; i < list.length; i++) {\n      entry = list[i];\n      debug('file %o: %o', i, entry.name);\n      if (entry.name == name) {\n        break;\n      }\n      entry = null;\n    }\n    if (entry) {\n      setLastMod(entry.date);\n    } else {\n      onerror(new NotFoundError());\n    }\n  }\n\n  // called when `lastModified` is set, and a \"cache\" stream was provided\n  function isNotModified() {\n    return +cache.lastModified == +lastModified;\n  }\n  opts.host = parsed.hostname || parsed.host || 'localhost';\n  opts.port = parseInt(parsed.port, 10) || 21;\n  if (debug.enabled) opts.debug = debug;\n  if (parsed.auth) {\n    const [user, password] = parsed.auth.split(\":\");\n    opts.user = user;\n    opts.password = password;\n  }\n  client.connect(opts);\n}","map":{"version":3,"names":["FTP","require","path","NotFoundError","NotModifiedError","debug","module","exports","get","parsed","opts","fn","cache","client","filepath","pathname","lastModified","once","onerror","onready","ongreeting","lastMod","onlastmod","greeting","err","end","onfile","stream","onend","getFile","lastmod","code","setLastMod","dir","dirname","list","onlist","isNotModified","setTimeout","bind","name","basename","entry","i","length","date","host","hostname","port","parseInt","enabled","auth","user","password","split","connect"],"sources":["/Users/sathyamurthyt/Documents/Ai-forms/form-wizard/node_modules/get-uri/ftp.js"],"sourcesContent":["\n/**\n * Module dependencies.\n */\n\nvar FTP = require('ftp');\nvar path = require('path');\nvar NotFoundError = require('./notfound');\nvar NotModifiedError = require('./notmodified');\nvar debug = require('debug')('get-uri:ftp');\n\n/**\n * Module exports.\n */\n\nmodule.exports = get;\n\n/**\n * Returns a Readable stream from an \"ftp:\" URI.\n *\n * @api protected\n */\n\nfunction get (parsed, opts, fn) {\n  var cache = opts.cache;\n  var client = new FTP();\n  var filepath = parsed.pathname;\n  var lastModified;\n\n  client.once('error', onerror);\n  client.once('ready', onready);\n  client.once('greeting', ongreeting);\n\n  function onready () {\n    // first we have to figure out the Last Modified date.\n    // try the MDTM command first, which is an optional extension command.\n    client.lastMod(filepath, onlastmod);\n  }\n\n  function ongreeting (greeting) {\n    debug('FTP greeting: %o', greeting);\n  }\n\n  function onerror (err) {\n    client.end();\n    fn(err);\n  }\n\n  function onfile (err, stream) {\n    if (err) return onerror(err);\n    stream.once('end', onend);\n    stream.lastModified = lastModified;\n    fn(null, stream);\n  }\n\n  function onend () {\n    // close the FTP client socket connection\n    client.end();\n  }\n\n  function getFile () {\n    client.get(filepath, onfile);\n  }\n\n  function onlastmod (err, lastmod) {\n    // handle the \"file not found\" error code\n    if (err) {\n      if (550 == err.code) {\n        onerror(new NotFoundError());\n      }\n      // any other error then we'll try the LIST command instead\n    }\n    if (lastmod) {\n      setLastMod(lastmod);\n    } else {\n      // try to get the last modified date via the LIST command (uses\n      // more bandwidth, but is more compatible with older FTP servers\n      var dir = path.dirname(filepath);\n      client.list(dir, onlist);\n    }\n  }\n\n  function setLastMod (lastmod) {\n    lastModified = lastmod;\n    if (cache && isNotModified()) {\n      // file is the same as in the \"cache\", return a not modified error\n      onerror(new NotModifiedError());\n    } else {\n      // XXX: a small timeout seemed necessary otherwise FTP servers\n      // were returning empty sockets for the file occasionally\n      setTimeout(client.get.bind(client, filepath, onfile), 10);\n    }\n  }\n\n  function onlist (err, list) {\n    if (err) return onerror(err);\n    var name = path.basename(filepath);\n\n    // attempt to find the \"entry\" with a matching \"name\"\n    var entry;\n    for (var i = 0; i < list.length; i++) {\n      entry = list[i];\n      debug('file %o: %o', i, entry.name);\n      if (entry.name == name) {\n        break;\n      }\n      entry = null;\n    }\n\n    if (entry) {\n      setLastMod(entry.date);\n    } else {\n      onerror(new NotFoundError());\n    }\n  }\n\n  // called when `lastModified` is set, and a \"cache\" stream was provided\n  function isNotModified () {\n    return +cache.lastModified == +lastModified;\n  }\n\n  opts.host = parsed.hostname || parsed.host || 'localhost';\n  opts.port = parseInt(parsed.port, 10) || 21;\n  if (debug.enabled) opts.debug = debug;\n\n  if (parsed.auth) {\n    const [user, password] = parsed.auth.split(\":\");\n    opts.user = user;\n    opts.password = password;\n  }\n  \n  client.connect(opts);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}