{"ast":null,"code":"'use strict';\n\nvar _fs = require('fs');\nvar _fs2 = _interopRequireDefault(_fs);\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nvar tags = require('./tags.json');\n\n/*\n unsignedByte,\n asciiStrings,\n unsignedShort,\n unsignedLong,\n unsignedRational,\n signedByte,\n undefined,\n signedShort,\n signedLong,\n signedRational,\n singleFloat,\n doubleFloat\n */\nvar bytes = [0, 1, 1, 2, 4, 8, 1, 1, 2, 4, 8, 4, 8];\nvar SOIMarkerLength = 2;\nvar JPEGSOIMarker = 0xffd8;\nvar TIFFINTEL = 0x4949;\nvar TIFFMOTOROLA = 0x4d4d;\nvar APPMarkerLength = 2;\nvar APPMarkerBegin = 0xffe0;\nvar APPMarkerEnd = 0xffef;\nvar data = void 0;\n/**\n * @param buffer {Buffer}\n * @returns {Boolean}\n * @example\n * var content = fs.readFileSync(\"~/Picture/IMG_0911.JPG\");\n * var isImage = isValid(content);\n * console.log(isImage);\n */\nvar isValid = function isValid(buffer) {\n  try {\n    var SOIMarker = buffer.readUInt16BE(0);\n    return SOIMarker === JPEGSOIMarker;\n  } catch (e) {\n    throw new Error('Unsupport file format.');\n  }\n};\n/**\n * @param buffer {Buffer}\n * @returns {Boolean}\n * @example\n */\nvar isTiff = function isTiff(buffer) {\n  try {\n    var SOIMarker = buffer.readUInt16BE(0);\n    return SOIMarker === TIFFINTEL || SOIMarker === TIFFMOTOROLA;\n  } catch (e) {\n    throw new Error('Unsupport file format.');\n  }\n};\n/**\n * @param buffer {Buffer}\n * @returns {Number}\n * @example\n * var content = fs.readFileSync(\"~/Picture/IMG_0911.JPG\");\n * var APPNumber = checkAPPn(content);\n * console.log(APPNumber);\n */\nvar checkAPPn = function checkAPPn(buffer) {\n  try {\n    var APPMarkerTag = buffer.readUInt16BE(0);\n    var isInRange = APPMarkerTag >= APPMarkerBegin && APPMarkerTag <= APPMarkerEnd;\n    return isInRange ? APPMarkerTag - APPMarkerBegin : false;\n  } catch (e) {\n    throw new Error('Invalid APP Tag.');\n  }\n};\n/**\n * @param buffer {Buffer}\n * @param tagCollection {Object}\n * @param order {Boolean}\n * @param offset {Number}\n * @returns {Object}\n * @example\n * var content = fs.readFileSync(\"~/Picture/IMG_0911.JPG\");\n * var exifFragments = IFDHandler(content, 0, true, 8);\n * console.log(exifFragments.value);\n */\nvar IFDHandler = function IFDHandler(buffer, tagCollection, order, offset) {\n  var entriesNumber = order ? buffer.readUInt16BE(0) : buffer.readUInt16LE(0);\n  if (entriesNumber === 0) {\n    return {};\n  }\n  var entriesNumberLength = 2;\n  var entries = buffer.slice(entriesNumberLength);\n  var entryLength = 12;\n  // let nextIFDPointerBegin = entriesNumberLength + entryLength * entriesNumber;\n  // let bigNextIFDPointer= buffer.readUInt32BE(nextIFDPointerBegin) ;\n  // let littleNextIFDPointer= buffer.readUInt32LE(nextIFDPointerBegin);\n  // let nextIFDPointer = order ?bigNextIFDPointer:littleNextIFDPointer;\n  var exif = {};\n  var entryCount = 0;\n  for (entryCount; entryCount < entriesNumber; entryCount += 1) {\n    var entryBegin = entryCount * entryLength;\n    var entry = entries.slice(entryBegin, entryBegin + entryLength);\n    var tagBegin = 0;\n    var tagLength = 2;\n    var dataFormatBegin = tagBegin + tagLength;\n    var dataFormatLength = 2;\n    var componentsBegin = dataFormatBegin + dataFormatLength;\n    var componentsNumberLength = 4;\n    var dataValueBegin = componentsBegin + componentsNumberLength;\n    var dataValueLength = 4;\n    var tagAddress = entry.slice(tagBegin, dataFormatBegin);\n    var tagNumber = order ? tagAddress.toString('hex') : tagAddress.reverse().toString('hex');\n    var tagName = tagCollection[tagNumber];\n    var bigDataFormat = entry.readUInt16BE(dataFormatBegin);\n    var littleDataFormat = entry.readUInt16LE(dataFormatBegin);\n    var dataFormat = order ? bigDataFormat : littleDataFormat;\n    var componentsByte = bytes[dataFormat];\n    var bigComponentsNumber = entry.readUInt32BE(componentsBegin);\n    var littleComponentNumber = entry.readUInt32LE(componentsBegin);\n    var componentsNumber = order ? bigComponentsNumber : littleComponentNumber;\n    var dataLength = componentsNumber * componentsByte;\n    var dataValue = entry.slice(dataValueBegin, dataValueBegin + dataValueLength);\n    if (dataLength > 4) {\n      var dataOffset = (order ? dataValue.readUInt32BE(0) : dataValue.readUInt32LE(0)) - offset;\n      dataValue = buffer.slice(dataOffset, dataOffset + dataLength);\n    }\n    var tagValue = void 0;\n    if (tagName) {\n      switch (dataFormat) {\n        case 1:\n          tagValue = dataValue.readUInt8(0);\n          break;\n        case 2:\n          tagValue = dataValue.toString('ascii').replace(/\\0+$/, '');\n          break;\n        case 3:\n          tagValue = order ? dataValue.readUInt16BE(0) : dataValue.readUInt16LE(0);\n          break;\n        case 4:\n          tagValue = order ? dataValue.readUInt32BE(0) : dataValue.readUInt32LE(0);\n          break;\n        case 5:\n          tagValue = [];\n          for (var i = 0; i < dataValue.length; i += 8) {\n            var bigTagValue = dataValue.readUInt32BE(i) / dataValue.readUInt32BE(i + 4);\n            var littleTagValue = dataValue.readUInt32LE(i) / dataValue.readUInt32LE(i + 4);\n            tagValue.push(order ? bigTagValue : littleTagValue);\n          }\n          break;\n        case 7:\n          switch (tagName) {\n            case 'ExifVersion':\n              tagValue = dataValue.toString();\n              break;\n            case 'FlashPixVersion':\n              tagValue = dataValue.toString();\n              break;\n            case 'SceneType':\n              tagValue = dataValue.readUInt8(0);\n              break;\n            default:\n              tagValue = '0x' + dataValue.toString('hex', 0, 15);\n              break;\n          }\n          break;\n        case 10:\n          {\n            var bigOrder = dataValue.readInt32BE(0) / dataValue.readInt32BE(4);\n            var littleOrder = dataValue.readInt32LE(0) / dataValue.readInt32LE(4);\n            tagValue = order ? bigOrder : littleOrder;\n            break;\n          }\n        default:\n          tagValue = '0x' + dataValue.toString('hex');\n          break;\n      }\n      exif[tagName] = tagValue;\n    }\n    /*\n     else {\n     console.log(`Unkown Tag [0x${tagNumber}].`);\n     }\n     */\n  }\n  return exif;\n};\n\n/**\n * @param buf {Buffer}\n * @returns {Undefined}\n * @example\n * var content = fs.readFileSync(\"~/Picture/IMG_0911.JPG\");\n * var exifFragments = EXIFHandler(content);\n */\nvar EXIFHandler = function EXIFHandler(buf) {\n  var pad = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  var buffer = buf;\n  if (pad) {\n    buffer = buf.slice(APPMarkerLength);\n    var length = buffer.readUInt16BE(0);\n    buffer = buffer.slice(0, length);\n    var lengthLength = 2;\n    buffer = buffer.slice(lengthLength);\n    var identifierLength = 5;\n    buffer = buffer.slice(identifierLength);\n    var padLength = 1;\n    buffer = buffer.slice(padLength);\n  }\n  var byteOrderLength = 2;\n  var byteOrder = buffer.toString('ascii', 0, byteOrderLength) === 'MM';\n  var fortyTwoLength = 2;\n  var fortyTwoEnd = byteOrderLength + fortyTwoLength;\n  var big42 = buffer.readUInt32BE(fortyTwoEnd);\n  var little42 = buffer.readUInt32LE(fortyTwoEnd);\n  var offsetOfIFD = byteOrder ? big42 : little42;\n  buffer = buffer.slice(offsetOfIFD);\n  if (buffer.length > 0) {\n    data = IFDHandler(buffer, tags.ifd, byteOrder, offsetOfIFD);\n    if (data.ExifIFDPointer) {\n      buffer = buffer.slice(data.ExifIFDPointer - offsetOfIFD);\n      data.SubExif = IFDHandler(buffer, tags.ifd, byteOrder, data.ExifIFDPointer);\n    }\n    if (data.GPSInfoIFDPointer) {\n      var gps = data.GPSInfoIFDPointer;\n      buffer = buffer.slice(data.ExifIFDPointer ? gps - data.ExifIFDPointer : gps - offsetOfIFD);\n      data.GPSInfo = IFDHandler(buffer, tags.gps, byteOrder, gps);\n    }\n  }\n};\n\n/**\n * @param buffer {Buffer}\n * @returns {Undefined}\n * @example\n * var content = fs.readFileSync(\"~/Picture/IMG_0911.JPG\");\n * var exifFragments = APPnHandler(content);\n */\nvar APPnHandler = function APPnHandler(buffer) {\n  var APPMarkerTag = checkAPPn(buffer);\n  if (APPMarkerTag !== false) {\n    // APP0 is 0, and 0==false\n    var length = buffer.readUInt16BE(APPMarkerLength);\n    switch (APPMarkerTag) {\n      case 1:\n        // EXIF\n        EXIFHandler(buffer);\n        break;\n      default:\n        APPnHandler(buffer.slice(APPMarkerLength + length));\n        break;\n    }\n  }\n};\n\n/**\n * @param buffer {Buffer}\n * @returns {Object}\n * @example\n */\nvar fromBuffer = function fromBuffer(buffer) {\n  if (!buffer) {\n    throw new Error('buffer not found');\n  }\n  data = undefined;\n  if (isValid(buffer)) {\n    buffer = buffer.slice(SOIMarkerLength);\n    data = {};\n    APPnHandler(buffer);\n  } else if (isTiff(buffer)) {\n    data = {};\n    EXIFHandler(buffer, false);\n  }\n  return data;\n};\n\n/**\n * @param file {String}\n * @returns {Object}\n * @example\n * var exif = sync(\"~/Picture/IMG_1981.JPG\");\n * console.log(exif.createTime);\n */\nvar sync = function sync(file) {\n  if (!file) {\n    throw new Error('File not found');\n  }\n  var buffer = _fs2.default.readFileSync(file);\n  return fromBuffer(buffer);\n};\n\n/**\n * @param file {String}\n * @param callback {Function}\n * @example\n * async(\"~/Picture/IMG_0707.JPG\", (err, data) => {\n *     if(err) {\n *         console.log(err);\n *     }\n *     if(data) {\n *         console.log(data.ExifOffset.createTime);\n *     }\n * }\n */\nvar async = function async(file, callback) {\n  data = undefined;\n  new Promise(function (resolve, reject) {\n    if (!file) {\n      reject(new Error('â“File not found.'));\n    }\n    _fs2.default.readFile(file, function (err, buffer) {\n      if (err) {\n        reject(err);\n      } else {\n        try {\n          if (isValid(buffer)) {\n            var buf = buffer.slice(SOIMarkerLength);\n            data = {};\n            APPnHandler(buf);\n            resolve(data);\n          } else if (isTiff(buffer)) {\n            data = {};\n            EXIFHandler(buffer, false);\n            resolve(data);\n          } else {\n            reject(new Error('ðŸ˜±Unsupport file type.'));\n          }\n        } catch (e) {\n          reject(e);\n        }\n      }\n    });\n  }, function (error) {\n    callback(error, undefined);\n  }).then(function (d) {\n    callback(undefined, d);\n  }).catch(function (error) {\n    callback(error, undefined);\n  });\n};\nexports.fromBuffer = fromBuffer;\nexports.parse = async;\nexports.parseSync = sync;","map":{"version":3,"names":["_fs","require","tags","bytes","SOIMarkerLength","JPEGSOIMarker","TIFFINTEL","TIFFMOTOROLA","APPMarkerLength","APPMarkerBegin","APPMarkerEnd","data","isValid","buffer","SOIMarker","readUInt16BE","e","Error","isTiff","checkAPPn","APPMarkerTag","isInRange","IFDHandler","tagCollection","order","offset","entriesNumber","readUInt16LE","entriesNumberLength","entries","slice","entryLength","exif","entryCount","entryBegin","entry","tagBegin","tagLength","dataFormatBegin","dataFormatLength","componentsBegin","componentsNumberLength","dataValueBegin","dataValueLength","tagAddress","tagNumber","toString","reverse","tagName","bigDataFormat","littleDataFormat","dataFormat","componentsByte","bigComponentsNumber","readUInt32BE","littleComponentNumber","readUInt32LE","componentsNumber","dataLength","dataValue","dataOffset","tagValue","readUInt8","replace","i","length","bigTagValue","littleTagValue","push","bigOrder","readInt32BE","littleOrder","readInt32LE","EXIFHandler","buf","pad","arguments","undefined","lengthLength","identifierLength","padLength","byteOrderLength","byteOrder","fortyTwoLength","fortyTwoEnd","big42","little42","offsetOfIFD","ifd","ExifIFDPointer","SubExif","GPSInfoIFDPointer","gps","GPSInfo","APPnHandler","fromBuffer","sync","file","_fs2","default","readFileSync","async","callback","Promise","resolve","reject","readFile","err","error","then","d","catch","exports","parse","parseSync"],"sources":["/Users/sathyamurthyt/Documents/Ai-forms/form-wizard/node_modules/jpeg-exif/src/index.js"],"sourcesContent":["import fs from 'fs';\n\nconst tags = require('./tags.json');\n\n/*\n unsignedByte,\n asciiStrings,\n unsignedShort,\n unsignedLong,\n unsignedRational,\n signedByte,\n undefined,\n signedShort,\n signedLong,\n signedRational,\n singleFloat,\n doubleFloat\n */\nconst bytes = [0, 1, 1, 2, 4, 8, 1, 1, 2, 4, 8, 4, 8];\nconst SOIMarkerLength = 2;\nconst JPEGSOIMarker = 0xffd8;\nconst TIFFINTEL = 0x4949;\nconst TIFFMOTOROLA = 0x4d4d;\nconst APPMarkerLength = 2;\nconst APPMarkerBegin = 0xffe0;\nconst APPMarkerEnd = 0xffef;\nlet data;\n/**\n * @param buffer {Buffer}\n * @returns {Boolean}\n * @example\n * var content = fs.readFileSync(\"~/Picture/IMG_0911.JPG\");\n * var isImage = isValid(content);\n * console.log(isImage);\n */\nconst isValid = (buffer) => {\n  try {\n    const SOIMarker = buffer.readUInt16BE(0);\n    return SOIMarker === JPEGSOIMarker;\n  } catch (e) {\n    throw new Error('Unsupport file format.');\n  }\n};\n/**\n * @param buffer {Buffer}\n * @returns {Boolean}\n * @example\n */\nconst isTiff = (buffer) => {\n  try {\n    const SOIMarker = buffer.readUInt16BE(0);\n    return SOIMarker === TIFFINTEL || SOIMarker === TIFFMOTOROLA;\n  } catch (e) {\n    throw new Error('Unsupport file format.');\n  }\n};\n/**\n * @param buffer {Buffer}\n * @returns {Number}\n * @example\n * var content = fs.readFileSync(\"~/Picture/IMG_0911.JPG\");\n * var APPNumber = checkAPPn(content);\n * console.log(APPNumber);\n */\nconst checkAPPn = (buffer) => {\n  try {\n    const APPMarkerTag = buffer.readUInt16BE(0);\n    const isInRange = APPMarkerTag >= APPMarkerBegin && APPMarkerTag <= APPMarkerEnd;\n    return isInRange ? APPMarkerTag - APPMarkerBegin : false;\n  } catch (e) {\n    throw new Error('Invalid APP Tag.');\n  }\n};\n/**\n * @param buffer {Buffer}\n * @param tagCollection {Object}\n * @param order {Boolean}\n * @param offset {Number}\n * @returns {Object}\n * @example\n * var content = fs.readFileSync(\"~/Picture/IMG_0911.JPG\");\n * var exifFragments = IFDHandler(content, 0, true, 8);\n * console.log(exifFragments.value);\n */\nconst IFDHandler = (buffer, tagCollection, order, offset) => {\n  const entriesNumber = order ? buffer.readUInt16BE(0) : buffer.readUInt16LE(0);\n\n  if (entriesNumber === 0) {\n    return {};\n  }\n\n  const entriesNumberLength = 2;\n  const entries = buffer.slice(entriesNumberLength);\n  const entryLength = 12;\n  // let nextIFDPointerBegin = entriesNumberLength + entryLength * entriesNumber;\n  // let bigNextIFDPointer= buffer.readUInt32BE(nextIFDPointerBegin) ;\n  // let littleNextIFDPointer= buffer.readUInt32LE(nextIFDPointerBegin);\n  // let nextIFDPointer = order ?bigNextIFDPointer:littleNextIFDPointer;\n  const exif = {};\n  let entryCount = 0;\n\n  for (entryCount; entryCount < entriesNumber; entryCount += 1) {\n    const entryBegin = entryCount * entryLength;\n    const entry = entries.slice(entryBegin, entryBegin + entryLength);\n    const tagBegin = 0;\n    const tagLength = 2;\n    const dataFormatBegin = tagBegin + tagLength;\n    const dataFormatLength = 2;\n    const componentsBegin = dataFormatBegin + dataFormatLength;\n    const componentsNumberLength = 4;\n    const dataValueBegin = componentsBegin + componentsNumberLength;\n    const dataValueLength = 4;\n    const tagAddress = entry.slice(tagBegin, dataFormatBegin);\n    const tagNumber = order ? tagAddress.toString('hex') : tagAddress.reverse().toString('hex');\n    const tagName = tagCollection[tagNumber];\n    const bigDataFormat = entry.readUInt16BE(dataFormatBegin);\n    const littleDataFormat = entry.readUInt16LE(dataFormatBegin);\n    const dataFormat = order ? bigDataFormat : littleDataFormat;\n    const componentsByte = bytes[dataFormat];\n    const bigComponentsNumber = entry.readUInt32BE(componentsBegin);\n    const littleComponentNumber = entry.readUInt32LE(componentsBegin);\n    const componentsNumber = order ? bigComponentsNumber : littleComponentNumber;\n    const dataLength = componentsNumber * componentsByte;\n    let dataValue = entry.slice(dataValueBegin, dataValueBegin + dataValueLength);\n\n    if (dataLength > 4) {\n      const dataOffset = (order ? dataValue.readUInt32BE(0) : dataValue.readUInt32LE(0)) - offset;\n      dataValue = buffer.slice(dataOffset, dataOffset + dataLength);\n    }\n\n    let tagValue;\n\n    if (tagName) {\n      switch (dataFormat) {\n        case 1:\n          tagValue = dataValue.readUInt8(0);\n          break;\n        case 2:\n          tagValue = dataValue.toString('ascii').replace(/\\0+$/, '');\n          break;\n        case 3:\n          tagValue = order ? dataValue.readUInt16BE(0) : dataValue.readUInt16LE(0);\n          break;\n        case 4:\n          tagValue = order ? dataValue.readUInt32BE(0) : dataValue.readUInt32LE(0);\n          break;\n        case 5:\n          tagValue = [];\n\n          for (let i = 0; i < dataValue.length; i += 8) {\n            const bigTagValue = dataValue.readUInt32BE(i) / dataValue.readUInt32BE(i + 4);\n            const littleTagValue = dataValue.readUInt32LE(i) / dataValue.readUInt32LE(i + 4);\n            tagValue.push(order ? bigTagValue : littleTagValue);\n          }\n\n          break;\n        case 7:\n          switch (tagName) {\n            case 'ExifVersion':\n              tagValue = dataValue.toString();\n              break;\n            case 'FlashPixVersion':\n              tagValue = dataValue.toString();\n              break;\n            case 'SceneType':\n              tagValue = dataValue.readUInt8(0);\n              break;\n            default:\n              tagValue = `0x${dataValue.toString('hex', 0, 15)}`;\n              break;\n          }\n          break;\n        case 10: {\n          const bigOrder = dataValue.readInt32BE(0) / dataValue.readInt32BE(4);\n          const littleOrder = dataValue.readInt32LE(0) / dataValue.readInt32LE(4);\n          tagValue = order ? bigOrder : littleOrder;\n          break;\n        }\n        default:\n          tagValue = `0x${dataValue.toString('hex')}`;\n          break;\n      }\n      exif[tagName] = tagValue;\n    }\n    /*\n     else {\n     console.log(`Unkown Tag [0x${tagNumber}].`);\n     }\n     */\n  }\n  return exif;\n};\n\n/**\n * @param buf {Buffer}\n * @returns {Undefined}\n * @example\n * var content = fs.readFileSync(\"~/Picture/IMG_0911.JPG\");\n * var exifFragments = EXIFHandler(content);\n */\nconst EXIFHandler = (buf, pad = true) => {\n  let buffer = buf;\n\n  if (pad) {\n    buffer = buf.slice(APPMarkerLength);\n    const length = buffer.readUInt16BE(0);\n    buffer = buffer.slice(0, length);\n    const lengthLength = 2;\n    buffer = buffer.slice(lengthLength);\n    const identifierLength = 5;\n    buffer = buffer.slice(identifierLength);\n    const padLength = 1;\n    buffer = buffer.slice(padLength);\n  }\n\n  const byteOrderLength = 2;\n  const byteOrder = buffer.toString('ascii', 0, byteOrderLength) === 'MM';\n  const fortyTwoLength = 2;\n  const fortyTwoEnd = byteOrderLength + fortyTwoLength;\n  const big42 = buffer.readUInt32BE(fortyTwoEnd);\n  const little42 = buffer.readUInt32LE(fortyTwoEnd);\n  const offsetOfIFD = byteOrder ? big42 : little42;\n\n  buffer = buffer.slice(offsetOfIFD);\n\n  if (buffer.length > 0) {\n    data = IFDHandler(buffer, tags.ifd, byteOrder, offsetOfIFD);\n\n    if (data.ExifIFDPointer) {\n      buffer = buffer.slice(data.ExifIFDPointer - offsetOfIFD);\n      data.SubExif = IFDHandler(buffer, tags.ifd, byteOrder, data.ExifIFDPointer);\n    }\n\n    if (data.GPSInfoIFDPointer) {\n      const gps = data.GPSInfoIFDPointer;\n      buffer = buffer.slice(data.ExifIFDPointer ? gps - data.ExifIFDPointer : gps - offsetOfIFD);\n      data.GPSInfo = IFDHandler(buffer, tags.gps, byteOrder, gps);\n    }\n  }\n};\n\n/**\n * @param buffer {Buffer}\n * @returns {Undefined}\n * @example\n * var content = fs.readFileSync(\"~/Picture/IMG_0911.JPG\");\n * var exifFragments = APPnHandler(content);\n */\nconst APPnHandler = (buffer) => {\n  const APPMarkerTag = checkAPPn(buffer);\n\n  if (APPMarkerTag !== false) { // APP0 is 0, and 0==false\n    const length = buffer.readUInt16BE(APPMarkerLength);\n\n    switch (APPMarkerTag) {\n      case 1: // EXIF\n        EXIFHandler(buffer);\n        break;\n      default:\n        APPnHandler(buffer.slice(APPMarkerLength + length));\n        break;\n    }\n  }\n};\n\n/**\n * @param buffer {Buffer}\n * @returns {Object}\n * @example\n */\nconst fromBuffer = (buffer) => {\n  if (!buffer) {\n    throw new Error('buffer not found');\n  }\n\n  data = undefined;\n\n  if (isValid(buffer)) {\n    buffer = buffer.slice(SOIMarkerLength);\n    data = {};\n    APPnHandler(buffer);\n  } else if (isTiff(buffer)) {\n    data = {};\n    EXIFHandler(buffer, false);\n  }\n\n  return data;\n};\n\n/**\n * @param file {String}\n * @returns {Object}\n * @example\n * var exif = sync(\"~/Picture/IMG_1981.JPG\");\n * console.log(exif.createTime);\n */\nconst sync = (file) => {\n  if (!file) {\n    throw new Error('File not found');\n  }\n\n  const buffer = fs.readFileSync(file);\n\n  return fromBuffer(buffer);\n};\n\n/**\n * @param file {String}\n * @param callback {Function}\n * @example\n * async(\"~/Picture/IMG_0707.JPG\", (err, data) => {\n *     if(err) {\n *         console.log(err);\n *     }\n *     if(data) {\n *         console.log(data.ExifOffset.createTime);\n *     }\n * }\n */\nconst async = (file, callback) => {\n  data = undefined;\n\n  new Promise((resolve, reject) => {\n    if (!file) {\n      reject(new Error('â“File not found.'));\n    }\n\n    fs.readFile(file, (err, buffer) => {\n      if (err) {\n        reject(err);\n      } else {\n        try {\n          if (isValid(buffer)) {\n            const buf = buffer.slice(SOIMarkerLength);\n\n            data = {};\n\n            APPnHandler(buf);\n            resolve(data);\n          } else if (isTiff(buffer)) {\n            data = {};\n\n            EXIFHandler(buffer, false);\n            resolve(data);\n          } else {\n            reject(new Error('ðŸ˜±Unsupport file type.'));\n          }\n        } catch (e) {\n          reject(e);\n        }\n      }\n    });\n  }, (error) => {\n    callback(error, undefined);\n  }).then((d) => {\n    callback(undefined, d);\n  }).catch((error) => {\n    callback(error, undefined);\n  });\n};\n\nexports.fromBuffer = fromBuffer;\nexports.parse = async;\nexports.parseSync = sync;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}