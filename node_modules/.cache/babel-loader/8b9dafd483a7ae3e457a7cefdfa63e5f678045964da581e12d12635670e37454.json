{"ast":null,"code":"/*\n * MIT LICENSE\n * Copyright (c) 2011 Devon Govett\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this\n * software and associated documentation files (the \"Software\"), to deal in the Software\n * without restriction, including without limitation the rights to use, copy, modify, merge,\n * publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons\n * to whom the Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all copies or\n * substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\n * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\nconst fs = require('fs');\nconst zlib = require('zlib');\nmodule.exports = class PNG {\n  static decode(path, fn) {\n    return fs.readFile(path, function (err, file) {\n      const png = new PNG(file);\n      return png.decode(pixels => fn(pixels));\n    });\n  }\n  static load(path) {\n    const file = fs.readFileSync(path);\n    return new PNG(file);\n  }\n  constructor(data) {\n    let i;\n    this.data = data;\n    this.pos = 8; // Skip the default header\n\n    this.palette = [];\n    this.imgData = [];\n    this.transparency = {};\n    this.text = {};\n    while (true) {\n      const chunkSize = this.readUInt32();\n      let section = '';\n      for (i = 0; i < 4; i++) {\n        section += String.fromCharCode(this.data[this.pos++]);\n      }\n      switch (section) {\n        case 'IHDR':\n          // we can grab  interesting values from here (like width, height, etc)\n          this.width = this.readUInt32();\n          this.height = this.readUInt32();\n          this.bits = this.data[this.pos++];\n          this.colorType = this.data[this.pos++];\n          this.compressionMethod = this.data[this.pos++];\n          this.filterMethod = this.data[this.pos++];\n          this.interlaceMethod = this.data[this.pos++];\n          break;\n        case 'PLTE':\n          this.palette = this.read(chunkSize);\n          break;\n        case 'IDAT':\n          for (i = 0; i < chunkSize; i++) {\n            this.imgData.push(this.data[this.pos++]);\n          }\n          break;\n        case 'tRNS':\n          // This chunk can only occur once and it must occur after the\n          // PLTE chunk and before the IDAT chunk.\n          this.transparency = {};\n          switch (this.colorType) {\n            case 3:\n              // Indexed color, RGB. Each byte in this chunk is an alpha for\n              // the palette index in the PLTE (\"palette\") chunk up until the\n              // last non-opaque entry. Set up an array, stretching over all\n              // palette entries which will be 0 (opaque) or 1 (transparent).\n              this.transparency.indexed = this.read(chunkSize);\n              var short = 255 - this.transparency.indexed.length;\n              if (short > 0) {\n                for (i = 0; i < short; i++) {\n                  this.transparency.indexed.push(255);\n                }\n              }\n              break;\n            case 0:\n              // Greyscale. Corresponding to entries in the PLTE chunk.\n              // Grey is two bytes, range 0 .. (2 ^ bit-depth) - 1\n              this.transparency.grayscale = this.read(chunkSize)[0];\n              break;\n            case 2:\n              // True color with proper alpha channel.\n              this.transparency.rgb = this.read(chunkSize);\n              break;\n          }\n          break;\n        case 'tEXt':\n          var text = this.read(chunkSize);\n          var index = text.indexOf(0);\n          var key = String.fromCharCode.apply(String, text.slice(0, index));\n          this.text[key] = String.fromCharCode.apply(String, text.slice(index + 1));\n          break;\n        case 'IEND':\n          // we've got everything we need!\n          switch (this.colorType) {\n            case 0:\n            case 3:\n            case 4:\n              this.colors = 1;\n              break;\n            case 2:\n            case 6:\n              this.colors = 3;\n              break;\n          }\n          this.hasAlphaChannel = [4, 6].includes(this.colorType);\n          var colors = this.colors + (this.hasAlphaChannel ? 1 : 0);\n          this.pixelBitlength = this.bits * colors;\n          switch (this.colors) {\n            case 1:\n              this.colorSpace = 'DeviceGray';\n              break;\n            case 3:\n              this.colorSpace = 'DeviceRGB';\n              break;\n          }\n          this.imgData = new Buffer(this.imgData);\n          return;\n          break;\n        default:\n          // unknown (or unimportant) section, skip it\n          this.pos += chunkSize;\n      }\n      this.pos += 4; // Skip the CRC\n\n      if (this.pos > this.data.length) {\n        throw new Error('Incomplete or corrupt PNG file');\n      }\n    }\n  }\n  read(bytes) {\n    const result = new Array(bytes);\n    for (let i = 0; i < bytes; i++) {\n      result[i] = this.data[this.pos++];\n    }\n    return result;\n  }\n  readUInt32() {\n    const b1 = this.data[this.pos++] << 24;\n    const b2 = this.data[this.pos++] << 16;\n    const b3 = this.data[this.pos++] << 8;\n    const b4 = this.data[this.pos++];\n    return b1 | b2 | b3 | b4;\n  }\n  readUInt16() {\n    const b1 = this.data[this.pos++] << 8;\n    const b2 = this.data[this.pos++];\n    return b1 | b2;\n  }\n  decodePixels(fn) {\n    return zlib.inflate(this.imgData, (err, data) => {\n      if (err) {\n        throw err;\n      }\n      const {\n        width,\n        height\n      } = this;\n      const pixelBytes = this.pixelBitlength / 8;\n      const pixels = new Buffer(width * height * pixelBytes);\n      const {\n        length\n      } = data;\n      let pos = 0;\n      function pass(x0, y0, dx, dy, singlePass = false) {\n        const w = Math.ceil((width - x0) / dx);\n        const h = Math.ceil((height - y0) / dy);\n        const scanlineLength = pixelBytes * w;\n        const buffer = singlePass ? pixels : new Buffer(scanlineLength * h);\n        let row = 0;\n        let c = 0;\n        while (row < h && pos < length) {\n          var byte, col, i, left, upper;\n          switch (data[pos++]) {\n            case 0:\n              // None\n              for (i = 0; i < scanlineLength; i++) {\n                buffer[c++] = data[pos++];\n              }\n              break;\n            case 1:\n              // Sub\n              for (i = 0; i < scanlineLength; i++) {\n                byte = data[pos++];\n                left = i < pixelBytes ? 0 : buffer[c - pixelBytes];\n                buffer[c++] = (byte + left) % 256;\n              }\n              break;\n            case 2:\n              // Up\n              for (i = 0; i < scanlineLength; i++) {\n                byte = data[pos++];\n                col = (i - i % pixelBytes) / pixelBytes;\n                upper = row && buffer[(row - 1) * scanlineLength + col * pixelBytes + i % pixelBytes];\n                buffer[c++] = (upper + byte) % 256;\n              }\n              break;\n            case 3:\n              // Average\n              for (i = 0; i < scanlineLength; i++) {\n                byte = data[pos++];\n                col = (i - i % pixelBytes) / pixelBytes;\n                left = i < pixelBytes ? 0 : buffer[c - pixelBytes];\n                upper = row && buffer[(row - 1) * scanlineLength + col * pixelBytes + i % pixelBytes];\n                buffer[c++] = (byte + Math.floor((left + upper) / 2)) % 256;\n              }\n              break;\n            case 4:\n              // Paeth\n              for (i = 0; i < scanlineLength; i++) {\n                var paeth, upperLeft;\n                byte = data[pos++];\n                col = (i - i % pixelBytes) / pixelBytes;\n                left = i < pixelBytes ? 0 : buffer[c - pixelBytes];\n                if (row === 0) {\n                  upper = upperLeft = 0;\n                } else {\n                  upper = buffer[(row - 1) * scanlineLength + col * pixelBytes + i % pixelBytes];\n                  upperLeft = col && buffer[(row - 1) * scanlineLength + (col - 1) * pixelBytes + i % pixelBytes];\n                }\n                const p = left + upper - upperLeft;\n                const pa = Math.abs(p - left);\n                const pb = Math.abs(p - upper);\n                const pc = Math.abs(p - upperLeft);\n                if (pa <= pb && pa <= pc) {\n                  paeth = left;\n                } else if (pb <= pc) {\n                  paeth = upper;\n                } else {\n                  paeth = upperLeft;\n                }\n                buffer[c++] = (byte + paeth) % 256;\n              }\n              break;\n            default:\n              throw new Error(`Invalid filter algorithm: ${data[pos - 1]}`);\n          }\n          if (!singlePass) {\n            let pixelsPos = ((y0 + row * dy) * width + x0) * pixelBytes;\n            let bufferPos = row * scanlineLength;\n            for (i = 0; i < w; i++) {\n              for (let j = 0; j < pixelBytes; j++) pixels[pixelsPos++] = buffer[bufferPos++];\n              pixelsPos += (dx - 1) * pixelBytes;\n            }\n          }\n          row++;\n        }\n      }\n      if (this.interlaceMethod === 1) {\n        /*\n          1 6 4 6 2 6 4 6\n          7 7 7 7 7 7 7 7\n          5 6 5 6 5 6 5 6\n          7 7 7 7 7 7 7 7\n          3 6 4 6 3 6 4 6\n          7 7 7 7 7 7 7 7\n          5 6 5 6 5 6 5 6\n          7 7 7 7 7 7 7 7\n        */\n        pass(0, 0, 8, 8); // 1\n        pass(4, 0, 8, 8); // 2\n        pass(0, 4, 4, 8); // 3\n        pass(2, 0, 4, 4); // 4\n        pass(0, 2, 2, 4); // 5\n        pass(1, 0, 2, 2); // 6\n        pass(0, 1, 1, 2); // 7\n      } else {\n        pass(0, 0, 1, 1, true);\n      }\n      return fn(pixels);\n    });\n  }\n  decodePalette() {\n    const {\n      palette\n    } = this;\n    const {\n      length\n    } = palette;\n    const transparency = this.transparency.indexed || [];\n    const ret = new Buffer(transparency.length + length);\n    let pos = 0;\n    let c = 0;\n    for (let i = 0; i < length; i += 3) {\n      var left;\n      ret[pos++] = palette[i];\n      ret[pos++] = palette[i + 1];\n      ret[pos++] = palette[i + 2];\n      ret[pos++] = (left = transparency[c++]) != null ? left : 255;\n    }\n    return ret;\n  }\n  copyToImageData(imageData, pixels) {\n    let j, k;\n    let {\n      colors\n    } = this;\n    let palette = null;\n    let alpha = this.hasAlphaChannel;\n    if (this.palette.length) {\n      palette = this._decodedPalette || (this._decodedPalette = this.decodePalette());\n      colors = 4;\n      alpha = true;\n    }\n    const data = imageData.data || imageData;\n    const {\n      length\n    } = data;\n    const input = palette || pixels;\n    let i = j = 0;\n    if (colors === 1) {\n      while (i < length) {\n        k = palette ? pixels[i / 4] * 4 : j;\n        const v = input[k++];\n        data[i++] = v;\n        data[i++] = v;\n        data[i++] = v;\n        data[i++] = alpha ? input[k++] : 255;\n        j = k;\n      }\n    } else {\n      while (i < length) {\n        k = palette ? pixels[i / 4] * 4 : j;\n        data[i++] = input[k++];\n        data[i++] = input[k++];\n        data[i++] = input[k++];\n        data[i++] = alpha ? input[k++] : 255;\n        j = k;\n      }\n    }\n  }\n  decode(fn) {\n    const ret = new Buffer(this.width * this.height * 4);\n    return this.decodePixels(pixels => {\n      this.copyToImageData(ret, pixels);\n      return fn(ret);\n    });\n  }\n};","map":{"version":3,"names":["fs","require","zlib","module","exports","PNG","decode","path","fn","readFile","err","file","png","pixels","load","readFileSync","constructor","data","i","pos","palette","imgData","transparency","text","chunkSize","readUInt32","section","String","fromCharCode","width","height","bits","colorType","compressionMethod","filterMethod","interlaceMethod","read","push","indexed","short","length","grayscale","rgb","index","indexOf","key","apply","slice","colors","hasAlphaChannel","includes","pixelBitlength","colorSpace","Buffer","Error","bytes","result","Array","b1","b2","b3","b4","readUInt16","decodePixels","inflate","pixelBytes","pass","x0","y0","dx","dy","singlePass","w","Math","ceil","h","scanlineLength","buffer","row","c","byte","col","left","upper","floor","paeth","upperLeft","p","pa","abs","pb","pc","pixelsPos","bufferPos","j","decodePalette","ret","copyToImageData","imageData","k","alpha","_decodedPalette","input","v"],"sources":["/Users/sathyamurthyt/Documents/Ai-forms/form-wizard/node_modules/png-js/png-node.js"],"sourcesContent":["/*\n * MIT LICENSE\n * Copyright (c) 2011 Devon Govett\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this\n * software and associated documentation files (the \"Software\"), to deal in the Software\n * without restriction, including without limitation the rights to use, copy, modify, merge,\n * publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons\n * to whom the Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all copies or\n * substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\n * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\nconst fs = require('fs');\nconst zlib = require('zlib');\n\nmodule.exports = class PNG {\n  static decode(path, fn) {\n    return fs.readFile(path, function(err, file) {\n      const png = new PNG(file);\n      return png.decode(pixels => fn(pixels));\n    });\n  }\n\n  static load(path) {\n    const file = fs.readFileSync(path);\n    return new PNG(file);\n  }\n\n  constructor(data) {\n    let i;\n    this.data = data;\n    this.pos = 8; // Skip the default header\n\n    this.palette = [];\n    this.imgData = [];\n    this.transparency = {};\n    this.text = {};\n\n    while (true) {\n      const chunkSize = this.readUInt32();\n      let section = '';\n      for (i = 0; i < 4; i++) {\n        section += String.fromCharCode(this.data[this.pos++]);\n      }\n\n      switch (section) {\n        case 'IHDR':\n          // we can grab  interesting values from here (like width, height, etc)\n          this.width = this.readUInt32();\n          this.height = this.readUInt32();\n          this.bits = this.data[this.pos++];\n          this.colorType = this.data[this.pos++];\n          this.compressionMethod = this.data[this.pos++];\n          this.filterMethod = this.data[this.pos++];\n          this.interlaceMethod = this.data[this.pos++];\n          break;\n\n        case 'PLTE':\n          this.palette = this.read(chunkSize);\n          break;\n\n        case 'IDAT':\n          for (i = 0; i < chunkSize; i++) {\n            this.imgData.push(this.data[this.pos++]);\n          }\n          break;\n\n        case 'tRNS':\n          // This chunk can only occur once and it must occur after the\n          // PLTE chunk and before the IDAT chunk.\n          this.transparency = {};\n          switch (this.colorType) {\n            case 3:\n              // Indexed color, RGB. Each byte in this chunk is an alpha for\n              // the palette index in the PLTE (\"palette\") chunk up until the\n              // last non-opaque entry. Set up an array, stretching over all\n              // palette entries which will be 0 (opaque) or 1 (transparent).\n              this.transparency.indexed = this.read(chunkSize);\n              var short = 255 - this.transparency.indexed.length;\n              if (short > 0) {\n                for (i = 0; i < short; i++) {\n                  this.transparency.indexed.push(255);\n                }\n              }\n              break;\n            case 0:\n              // Greyscale. Corresponding to entries in the PLTE chunk.\n              // Grey is two bytes, range 0 .. (2 ^ bit-depth) - 1\n              this.transparency.grayscale = this.read(chunkSize)[0];\n              break;\n            case 2:\n              // True color with proper alpha channel.\n              this.transparency.rgb = this.read(chunkSize);\n              break;\n          }\n          break;\n\n        case 'tEXt':\n          var text = this.read(chunkSize);\n          var index = text.indexOf(0);\n          var key = String.fromCharCode.apply(String, text.slice(0, index));\n          this.text[key] = String.fromCharCode.apply(\n            String,\n            text.slice(index + 1)\n          );\n          break;\n\n        case 'IEND':\n          // we've got everything we need!\n          switch (this.colorType) {\n            case 0:\n            case 3:\n            case 4:\n              this.colors = 1;\n              break;\n            case 2:\n            case 6:\n              this.colors = 3;\n              break;\n          }\n\n          this.hasAlphaChannel = [4, 6].includes(this.colorType);\n          var colors = this.colors + (this.hasAlphaChannel ? 1 : 0);\n          this.pixelBitlength = this.bits * colors;\n\n          switch (this.colors) {\n            case 1:\n              this.colorSpace = 'DeviceGray';\n              break;\n            case 3:\n              this.colorSpace = 'DeviceRGB';\n              break;\n          }\n\n          this.imgData = new Buffer(this.imgData);\n          return;\n          break;\n\n        default:\n          // unknown (or unimportant) section, skip it\n          this.pos += chunkSize;\n      }\n\n      this.pos += 4; // Skip the CRC\n\n      if (this.pos > this.data.length) {\n        throw new Error('Incomplete or corrupt PNG file');\n      }\n    }\n  }\n\n  read(bytes) {\n    const result = new Array(bytes);\n    for (let i = 0; i < bytes; i++) {\n      result[i] = this.data[this.pos++];\n    }\n    return result;\n  }\n\n  readUInt32() {\n    const b1 = this.data[this.pos++] << 24;\n    const b2 = this.data[this.pos++] << 16;\n    const b3 = this.data[this.pos++] << 8;\n    const b4 = this.data[this.pos++];\n    return b1 | b2 | b3 | b4;\n  }\n\n  readUInt16() {\n    const b1 = this.data[this.pos++] << 8;\n    const b2 = this.data[this.pos++];\n    return b1 | b2;\n  }\n\n  decodePixels(fn) {\n    return zlib.inflate(this.imgData, (err, data) => {\n      if (err) {\n        throw err;\n      }\n\n      const { width, height } = this;\n      const pixelBytes = this.pixelBitlength / 8;\n\n      const pixels = new Buffer(width * height * pixelBytes);\n      const { length } = data;\n      let pos = 0;\n\n      function pass(x0, y0, dx, dy, singlePass = false) {\n        const w = Math.ceil((width - x0) / dx);\n        const h = Math.ceil((height - y0) / dy);\n        const scanlineLength = pixelBytes * w;\n        const buffer = singlePass ? pixels : new Buffer(scanlineLength * h);\n        let row = 0;\n        let c = 0;\n        while (row < h && pos < length) {\n          var byte, col, i, left, upper;\n          switch (data[pos++]) {\n            case 0: // None\n              for (i = 0; i < scanlineLength; i++) {\n                buffer[c++] = data[pos++];\n              }\n              break;\n\n            case 1: // Sub\n              for (i = 0; i < scanlineLength; i++) {\n                byte = data[pos++];\n                left = i < pixelBytes ? 0 : buffer[c - pixelBytes];\n                buffer[c++] = (byte + left) % 256;\n              }\n              break;\n\n            case 2: // Up\n              for (i = 0; i < scanlineLength; i++) {\n                byte = data[pos++];\n                col = (i - (i % pixelBytes)) / pixelBytes;\n                upper =\n                  row &&\n                  buffer[\n                    (row - 1) * scanlineLength +\n                      col * pixelBytes +\n                      (i % pixelBytes)\n                  ];\n                buffer[c++] = (upper + byte) % 256;\n              }\n              break;\n\n            case 3: // Average\n              for (i = 0; i < scanlineLength; i++) {\n                byte = data[pos++];\n                col = (i - (i % pixelBytes)) / pixelBytes;\n                left = i < pixelBytes ? 0 : buffer[c - pixelBytes];\n                upper =\n                  row &&\n                  buffer[\n                    (row - 1) * scanlineLength +\n                      col * pixelBytes +\n                      (i % pixelBytes)\n                  ];\n                buffer[c++] = (byte + Math.floor((left + upper) / 2)) % 256;\n              }\n              break;\n\n            case 4: // Paeth\n              for (i = 0; i < scanlineLength; i++) {\n                var paeth, upperLeft;\n                byte = data[pos++];\n                col = (i - (i % pixelBytes)) / pixelBytes;\n                left = i < pixelBytes ? 0 : buffer[c - pixelBytes];\n\n                if (row === 0) {\n                  upper = upperLeft = 0;\n                } else {\n                  upper =\n                    buffer[\n                      (row - 1) * scanlineLength +\n                        col * pixelBytes +\n                        (i % pixelBytes)\n                    ];\n                  upperLeft =\n                    col &&\n                    buffer[\n                      (row - 1) * scanlineLength +\n                        (col - 1) * pixelBytes +\n                        (i % pixelBytes)\n                    ];\n                }\n\n                const p = left + upper - upperLeft;\n                const pa = Math.abs(p - left);\n                const pb = Math.abs(p - upper);\n                const pc = Math.abs(p - upperLeft);\n\n                if (pa <= pb && pa <= pc) {\n                  paeth = left;\n                } else if (pb <= pc) {\n                  paeth = upper;\n                } else {\n                  paeth = upperLeft;\n                }\n\n                buffer[c++] = (byte + paeth) % 256;\n              }\n              break;\n\n            default:\n              throw new Error(`Invalid filter algorithm: ${data[pos - 1]}`);\n          }\n\n          if (!singlePass) {\n            let pixelsPos = ((y0 + row * dy) * width + x0) * pixelBytes;\n            let bufferPos = row * scanlineLength;\n            for (i = 0; i < w; i++) {\n              for (let j = 0; j < pixelBytes; j++)\n                pixels[pixelsPos++] = buffer[bufferPos++];\n              pixelsPos += (dx - 1) * pixelBytes;\n            }\n          }\n\n          row++;\n        }\n      }\n\n      if (this.interlaceMethod === 1) {\n        /*\n          1 6 4 6 2 6 4 6\n          7 7 7 7 7 7 7 7\n          5 6 5 6 5 6 5 6\n          7 7 7 7 7 7 7 7\n          3 6 4 6 3 6 4 6\n          7 7 7 7 7 7 7 7\n          5 6 5 6 5 6 5 6\n          7 7 7 7 7 7 7 7\n        */\n        pass(0, 0, 8, 8); // 1\n        pass(4, 0, 8, 8); // 2\n        pass(0, 4, 4, 8); // 3\n        pass(2, 0, 4, 4); // 4\n        pass(0, 2, 2, 4); // 5\n        pass(1, 0, 2, 2); // 6\n        pass(0, 1, 1, 2); // 7\n      } else {\n        pass(0, 0, 1, 1, true);\n      }\n\n      return fn(pixels);\n    });\n  }\n\n  decodePalette() {\n    const { palette } = this;\n    const { length } = palette;\n    const transparency = this.transparency.indexed || [];\n    const ret = new Buffer(transparency.length + length);\n    let pos = 0;\n    let c = 0;\n\n    for (let i = 0; i < length; i += 3) {\n      var left;\n      ret[pos++] = palette[i];\n      ret[pos++] = palette[i + 1];\n      ret[pos++] = palette[i + 2];\n      ret[pos++] = (left = transparency[c++]) != null ? left : 255;\n    }\n\n    return ret;\n  }\n\n  copyToImageData(imageData, pixels) {\n    let j, k;\n    let { colors } = this;\n    let palette = null;\n    let alpha = this.hasAlphaChannel;\n\n    if (this.palette.length) {\n      palette =\n        this._decodedPalette || (this._decodedPalette = this.decodePalette());\n      colors = 4;\n      alpha = true;\n    }\n\n    const data = imageData.data || imageData;\n    const { length } = data;\n    const input = palette || pixels;\n    let i = (j = 0);\n\n    if (colors === 1) {\n      while (i < length) {\n        k = palette ? pixels[i / 4] * 4 : j;\n        const v = input[k++];\n        data[i++] = v;\n        data[i++] = v;\n        data[i++] = v;\n        data[i++] = alpha ? input[k++] : 255;\n        j = k;\n      }\n    } else {\n      while (i < length) {\n        k = palette ? pixels[i / 4] * 4 : j;\n        data[i++] = input[k++];\n        data[i++] = input[k++];\n        data[i++] = input[k++];\n        data[i++] = alpha ? input[k++] : 255;\n        j = k;\n      }\n    }\n  }\n\n  decode(fn) {\n    const ret = new Buffer(this.width * this.height * 4);\n    return this.decodePixels(pixels => {\n      this.copyToImageData(ret, pixels);\n      return fn(ret);\n    });\n  }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}