{"ast":null,"code":"/**\n * Module dependencies.\n */\n\nvar tls; // lazy-loaded...\nvar url = require('url');\nvar dns = require('dns');\nvar Agent = require('agent-base');\nvar SocksClient = require('socks').SocksClient;\nvar inherits = require('util').inherits;\n\n/**\n * Module exports.\n */\n\nmodule.exports = SocksProxyAgent;\n\n/**\n * The `SocksProxyAgent`.\n *\n * @api public\n */\n\nfunction SocksProxyAgent(opts) {\n  if (!(this instanceof SocksProxyAgent)) return new SocksProxyAgent(opts);\n  if ('string' == typeof opts) opts = url.parse(opts);\n  if (!opts) throw new Error('a SOCKS proxy server `host` and `port` must be specified!');\n  Agent.call(this, opts);\n  var proxy = Object.assign({}, opts);\n\n  // prefer `hostname` over `host`, because of `url.parse()`\n  proxy.host = proxy.hostname || proxy.host;\n\n  // SOCKS doesn't *technically* have a default port, but this is\n  // the same default that `curl(1)` uses\n  proxy.port = +proxy.port || 1080;\n  if (proxy.host && proxy.path) {\n    // if both a `host` and `path` are specified then it's most likely the\n    // result of a `url.parse()` call... we need to remove the `path` portion so\n    // that `net.connect()` doesn't attempt to open that as a unix socket file.\n    delete proxy.path;\n    delete proxy.pathname;\n  }\n\n  // figure out if we want socks v4 or v5, based on the \"protocol\" used.\n  // Defaults to 5.\n  proxy.lookup = false;\n  switch (proxy.protocol) {\n    case 'socks4:':\n      proxy.lookup = true;\n    // pass through\n    case 'socks4a:':\n      proxy.version = 4;\n      break;\n    case 'socks5:':\n      proxy.lookup = true;\n    // pass through\n    case 'socks:': // no version specified, default to 5h\n    case 'socks5h:':\n      proxy.version = 5;\n      break;\n    default:\n      throw new TypeError('A \"socks\" protocol must be specified! Got: ' + proxy.protocol);\n  }\n  if (proxy.auth) {\n    var auth = proxy.auth.split(':');\n    proxy.authentication = {\n      username: auth[0],\n      password: auth[1]\n    };\n    proxy.userid = auth[0];\n  }\n  this.proxy = proxy;\n}\ninherits(SocksProxyAgent, Agent);\n\n/**\n * Initiates a SOCKS connection to the specified SOCKS proxy server,\n * which in turn connects to the specified remote host and port.\n *\n * @api public\n */\n\nSocksProxyAgent.prototype.callback = function connect(req, opts, fn) {\n  var proxy = this.proxy;\n\n  // called once the SOCKS proxy has connected to the specified remote endpoint\n  function onhostconnect(err, result) {\n    if (err) return fn(err);\n    var socket = result.socket;\n    var s = socket;\n    if (opts.secureEndpoint) {\n      // since the proxy is connecting to an SSL server, we have\n      // to upgrade this socket connection to an SSL connection\n      if (!tls) tls = require('tls');\n      opts.socket = socket;\n      opts.servername = opts.host;\n      opts.host = null;\n      opts.hostname = null;\n      opts.port = null;\n      s = tls.connect(opts);\n    }\n    fn(null, s);\n  }\n\n  // called for the `dns.lookup()` callback\n  function onlookup(err, ip) {\n    if (err) return fn(err);\n    options.destination.host = ip;\n    SocksClient.createConnection(options, onhostconnect);\n  }\n  var options = {\n    proxy: {\n      ipaddress: proxy.host,\n      port: +proxy.port,\n      type: proxy.version\n    },\n    destination: {\n      port: +opts.port\n    },\n    command: 'connect'\n  };\n  if (proxy.authentication) {\n    options.proxy.userId = proxy.userid;\n    options.proxy.password = proxy.authentication.password;\n  }\n  if (proxy.lookup) {\n    // client-side DNS resolution for \"4\" and \"5\" socks proxy versions\n    dns.lookup(opts.host, onlookup);\n  } else {\n    // proxy hostname DNS resolution for \"4a\" and \"5h\" socks proxy servers\n    onlookup(null, opts.host);\n  }\n};","map":{"version":3,"names":["tls","url","require","dns","Agent","SocksClient","inherits","module","exports","SocksProxyAgent","opts","parse","Error","call","proxy","Object","assign","host","hostname","port","path","pathname","lookup","protocol","version","TypeError","auth","split","authentication","username","password","userid","prototype","callback","connect","req","fn","onhostconnect","err","result","socket","s","secureEndpoint","servername","onlookup","ip","options","destination","createConnection","ipaddress","type","command","userId"],"sources":["/Users/sathyamurthyt/Documents/Ai-forms/form-wizard/node_modules/socks-proxy-agent/index.js"],"sourcesContent":["/**\n * Module dependencies.\n */\n\nvar tls; // lazy-loaded...\nvar url = require('url');\nvar dns = require('dns');\nvar Agent = require('agent-base');\nvar SocksClient = require('socks').SocksClient;\nvar inherits = require('util').inherits;\n\n/**\n * Module exports.\n */\n\nmodule.exports = SocksProxyAgent;\n\n/**\n * The `SocksProxyAgent`.\n *\n * @api public\n */\n\nfunction SocksProxyAgent(opts) {\n  if (!(this instanceof SocksProxyAgent)) return new SocksProxyAgent(opts);\n  if ('string' == typeof opts) opts = url.parse(opts);\n  if (!opts)\n    throw new Error(\n      'a SOCKS proxy server `host` and `port` must be specified!'\n    );\n  Agent.call(this, opts);\n\n  var proxy = Object.assign({}, opts);\n\n  // prefer `hostname` over `host`, because of `url.parse()`\n  proxy.host = proxy.hostname || proxy.host;\n\n  // SOCKS doesn't *technically* have a default port, but this is\n  // the same default that `curl(1)` uses\n  proxy.port = +proxy.port || 1080;\n\n  if (proxy.host && proxy.path) {\n    // if both a `host` and `path` are specified then it's most likely the\n    // result of a `url.parse()` call... we need to remove the `path` portion so\n    // that `net.connect()` doesn't attempt to open that as a unix socket file.\n    delete proxy.path;\n    delete proxy.pathname;\n  }\n\n  // figure out if we want socks v4 or v5, based on the \"protocol\" used.\n  // Defaults to 5.\n  proxy.lookup = false;\n  switch (proxy.protocol) {\n    case 'socks4:':\n      proxy.lookup = true;\n    // pass through\n    case 'socks4a:':\n      proxy.version = 4;\n      break;\n    case 'socks5:':\n      proxy.lookup = true;\n    // pass through\n    case 'socks:': // no version specified, default to 5h\n    case 'socks5h:':\n      proxy.version = 5;\n      break;\n    default:\n      throw new TypeError(\n        'A \"socks\" protocol must be specified! Got: ' + proxy.protocol\n      );\n  }\n\n  if (proxy.auth) {\n    var auth = proxy.auth.split(':');\n    proxy.authentication = { username: auth[0], password: auth[1] };\n    proxy.userid = auth[0];\n  }\n  this.proxy = proxy;\n}\ninherits(SocksProxyAgent, Agent);\n\n/**\n * Initiates a SOCKS connection to the specified SOCKS proxy server,\n * which in turn connects to the specified remote host and port.\n *\n * @api public\n */\n\nSocksProxyAgent.prototype.callback = function connect(req, opts, fn) {\n  var proxy = this.proxy;\n\n  // called once the SOCKS proxy has connected to the specified remote endpoint\n  function onhostconnect(err, result) {\n    if (err) return fn(err);\n\n    var socket = result.socket;\n\n    var s = socket;\n    if (opts.secureEndpoint) {\n      // since the proxy is connecting to an SSL server, we have\n      // to upgrade this socket connection to an SSL connection\n      if (!tls) tls = require('tls');\n      opts.socket = socket;\n      opts.servername = opts.host;\n      opts.host = null;\n      opts.hostname = null;\n      opts.port = null;\n      s = tls.connect(opts);\n    }\n\n    fn(null, s);\n  }\n\n  // called for the `dns.lookup()` callback\n  function onlookup(err, ip) {\n    if (err) return fn(err);\n    options.destination.host = ip;\n    SocksClient.createConnection(options, onhostconnect);\n  }\n\n  var options = {\n    proxy: {\n      ipaddress: proxy.host,\n      port: +proxy.port,\n      type: proxy.version\n    },\n    destination: {\n      port: +opts.port\n    },\n    command: 'connect'\n  };\n\n  if (proxy.authentication) {\n    options.proxy.userId = proxy.userid;\n    options.proxy.password = proxy.authentication.password;\n  }\n\n  if (proxy.lookup) {\n    // client-side DNS resolution for \"4\" and \"5\" socks proxy versions\n    dns.lookup(opts.host, onlookup);\n  } else {\n    // proxy hostname DNS resolution for \"4a\" and \"5h\" socks proxy servers\n    onlookup(null, opts.host);\n  }\n}\n"],"mappings":"AAAA;AACA;AACA;;AAEA,IAAIA,GAAG,CAAC,CAAC;AACT,IAAIC,GAAG,GAAGC,OAAO,CAAC,KAAK,CAAC;AACxB,IAAIC,GAAG,GAAGD,OAAO,CAAC,KAAK,CAAC;AACxB,IAAIE,KAAK,GAAGF,OAAO,CAAC,YAAY,CAAC;AACjC,IAAIG,WAAW,GAAGH,OAAO,CAAC,OAAO,CAAC,CAACG,WAAW;AAC9C,IAAIC,QAAQ,GAAGJ,OAAO,CAAC,MAAM,CAAC,CAACI,QAAQ;;AAEvC;AACA;AACA;;AAEAC,MAAM,CAACC,OAAO,GAAGC,eAAe;;AAEhC;AACA;AACA;AACA;AACA;;AAEA,SAASA,eAAeA,CAACC,IAAI,EAAE;EAC7B,IAAI,EAAE,IAAI,YAAYD,eAAe,CAAC,EAAE,OAAO,IAAIA,eAAe,CAACC,IAAI,CAAC;EACxE,IAAI,QAAQ,IAAI,OAAOA,IAAI,EAAEA,IAAI,GAAGT,GAAG,CAACU,KAAK,CAACD,IAAI,CAAC;EACnD,IAAI,CAACA,IAAI,EACP,MAAM,IAAIE,KAAK,CACb,2DACF,CAAC;EACHR,KAAK,CAACS,IAAI,CAAC,IAAI,EAAEH,IAAI,CAAC;EAEtB,IAAII,KAAK,GAAGC,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAEN,IAAI,CAAC;;EAEnC;EACAI,KAAK,CAACG,IAAI,GAAGH,KAAK,CAACI,QAAQ,IAAIJ,KAAK,CAACG,IAAI;;EAEzC;EACA;EACAH,KAAK,CAACK,IAAI,GAAG,CAACL,KAAK,CAACK,IAAI,IAAI,IAAI;EAEhC,IAAIL,KAAK,CAACG,IAAI,IAAIH,KAAK,CAACM,IAAI,EAAE;IAC5B;IACA;IACA;IACA,OAAON,KAAK,CAACM,IAAI;IACjB,OAAON,KAAK,CAACO,QAAQ;EACvB;;EAEA;EACA;EACAP,KAAK,CAACQ,MAAM,GAAG,KAAK;EACpB,QAAQR,KAAK,CAACS,QAAQ;IACpB,KAAK,SAAS;MACZT,KAAK,CAACQ,MAAM,GAAG,IAAI;IACrB;IACA,KAAK,UAAU;MACbR,KAAK,CAACU,OAAO,GAAG,CAAC;MACjB;IACF,KAAK,SAAS;MACZV,KAAK,CAACQ,MAAM,GAAG,IAAI;IACrB;IACA,KAAK,QAAQ,CAAC,CAAC;IACf,KAAK,UAAU;MACbR,KAAK,CAACU,OAAO,GAAG,CAAC;MACjB;IACF;MACE,MAAM,IAAIC,SAAS,CACjB,6CAA6C,GAAGX,KAAK,CAACS,QACxD,CAAC;EACL;EAEA,IAAIT,KAAK,CAACY,IAAI,EAAE;IACd,IAAIA,IAAI,GAAGZ,KAAK,CAACY,IAAI,CAACC,KAAK,CAAC,GAAG,CAAC;IAChCb,KAAK,CAACc,cAAc,GAAG;MAAEC,QAAQ,EAAEH,IAAI,CAAC,CAAC,CAAC;MAAEI,QAAQ,EAAEJ,IAAI,CAAC,CAAC;IAAE,CAAC;IAC/DZ,KAAK,CAACiB,MAAM,GAAGL,IAAI,CAAC,CAAC,CAAC;EACxB;EACA,IAAI,CAACZ,KAAK,GAAGA,KAAK;AACpB;AACAR,QAAQ,CAACG,eAAe,EAAEL,KAAK,CAAC;;AAEhC;AACA;AACA;AACA;AACA;AACA;;AAEAK,eAAe,CAACuB,SAAS,CAACC,QAAQ,GAAG,SAASC,OAAOA,CAACC,GAAG,EAAEzB,IAAI,EAAE0B,EAAE,EAAE;EACnE,IAAItB,KAAK,GAAG,IAAI,CAACA,KAAK;;EAEtB;EACA,SAASuB,aAAaA,CAACC,GAAG,EAAEC,MAAM,EAAE;IAClC,IAAID,GAAG,EAAE,OAAOF,EAAE,CAACE,GAAG,CAAC;IAEvB,IAAIE,MAAM,GAAGD,MAAM,CAACC,MAAM;IAE1B,IAAIC,CAAC,GAAGD,MAAM;IACd,IAAI9B,IAAI,CAACgC,cAAc,EAAE;MACvB;MACA;MACA,IAAI,CAAC1C,GAAG,EAAEA,GAAG,GAAGE,OAAO,CAAC,KAAK,CAAC;MAC9BQ,IAAI,CAAC8B,MAAM,GAAGA,MAAM;MACpB9B,IAAI,CAACiC,UAAU,GAAGjC,IAAI,CAACO,IAAI;MAC3BP,IAAI,CAACO,IAAI,GAAG,IAAI;MAChBP,IAAI,CAACQ,QAAQ,GAAG,IAAI;MACpBR,IAAI,CAACS,IAAI,GAAG,IAAI;MAChBsB,CAAC,GAAGzC,GAAG,CAACkC,OAAO,CAACxB,IAAI,CAAC;IACvB;IAEA0B,EAAE,CAAC,IAAI,EAAEK,CAAC,CAAC;EACb;;EAEA;EACA,SAASG,QAAQA,CAACN,GAAG,EAAEO,EAAE,EAAE;IACzB,IAAIP,GAAG,EAAE,OAAOF,EAAE,CAACE,GAAG,CAAC;IACvBQ,OAAO,CAACC,WAAW,CAAC9B,IAAI,GAAG4B,EAAE;IAC7BxC,WAAW,CAAC2C,gBAAgB,CAACF,OAAO,EAAET,aAAa,CAAC;EACtD;EAEA,IAAIS,OAAO,GAAG;IACZhC,KAAK,EAAE;MACLmC,SAAS,EAAEnC,KAAK,CAACG,IAAI;MACrBE,IAAI,EAAE,CAACL,KAAK,CAACK,IAAI;MACjB+B,IAAI,EAAEpC,KAAK,CAACU;IACd,CAAC;IACDuB,WAAW,EAAE;MACX5B,IAAI,EAAE,CAACT,IAAI,CAACS;IACd,CAAC;IACDgC,OAAO,EAAE;EACX,CAAC;EAED,IAAIrC,KAAK,CAACc,cAAc,EAAE;IACxBkB,OAAO,CAAChC,KAAK,CAACsC,MAAM,GAAGtC,KAAK,CAACiB,MAAM;IACnCe,OAAO,CAAChC,KAAK,CAACgB,QAAQ,GAAGhB,KAAK,CAACc,cAAc,CAACE,QAAQ;EACxD;EAEA,IAAIhB,KAAK,CAACQ,MAAM,EAAE;IAChB;IACAnB,GAAG,CAACmB,MAAM,CAACZ,IAAI,CAACO,IAAI,EAAE2B,QAAQ,CAAC;EACjC,CAAC,MAAM;IACL;IACAA,QAAQ,CAAC,IAAI,EAAElC,IAAI,CAACO,IAAI,CAAC;EAC3B;AACF,CAAC","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}