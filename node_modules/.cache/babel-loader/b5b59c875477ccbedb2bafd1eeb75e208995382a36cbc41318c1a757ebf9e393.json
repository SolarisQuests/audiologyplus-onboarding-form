{"ast":null,"code":"/**\n * Module dependencies.\n */\n\nvar url = require('url');\nvar http = require('http');\nvar https = require('https');\nvar extend = require('extend');\nvar NotFoundError = require('./notfound');\nvar NotModifiedError = require('./notmodified');\nvar debug = require('debug')('get-uri:http');\n\n/**\n * Module exports.\n */\n\nmodule.exports = get;\n\n/**\n * Returns a Readable stream from an \"http:\" URI.\n *\n * @api protected\n */\n\nfunction get(parsed, opts, fn) {\n  debug('GET %o', parsed.href);\n  var cache = getCache(parsed, opts.cache);\n\n  // 5 redirects allowed by default\n  var maxRedirects = opts.hasOwnProperty('maxRedirects') ? opts.maxRedirects : 5;\n  debug('allowing %o max redirects', maxRedirects);\n\n  // first check the previous Expires and/or Cache-Control headers\n  // of a previous response if a `cache` was provided\n  if (cache && isFresh(cache)) {\n    // check for a 3xx \"redirect\" status code on the previous cache\n    var location = cache.headers.location;\n    var type = cache.statusCode / 100 | 0;\n    if (3 == type && location) {\n      debug('cached redirect');\n      fn(new Error('TODO: implement cached redirects!'));\n    } else {\n      // otherwise we assume that it's the destination endpoint,\n      // since there's nowhere else to redirect to\n      fn(new NotModifiedError());\n    }\n    return;\n  }\n  var mod;\n  if (opts.http) {\n    // the `https` module passed in from the \"http.js\" file\n    mod = opts.http;\n    debug('using secure `https` core module');\n  } else {\n    mod = http;\n    debug('using `http` core module');\n  }\n  var options = extend({}, opts, parsed);\n\n  // add \"cache validation\" headers if a `cache` was provided\n  if (cache) {\n    if (!options.headers) options.headers = {};\n    var lastModified = cache.headers['last-modified'];\n    if (lastModified != null) {\n      options.headers['If-Modified-Since'] = lastModified;\n      debug('added \"If-Modified-Since\" request header: %o', lastModified);\n    }\n    var etag = cache.headers.etag;\n    if (etag != null) {\n      options.headers['If-None-Match'] = etag;\n      debug('added \"If-None-Match\" request header: %o', etag);\n    }\n  }\n  var req = mod.get(options);\n  req.once('error', onerror);\n  req.once('response', onresponse);\n\n  // http.ClientRequest \"error\" event handler\n  function onerror(err) {\n    debug('http.ClientRequest \"error\" event: %o', err.stack || err);\n    fn(err);\n  }\n\n  // http.ClientRequest \"response\" event handler\n  function onresponse(res) {\n    var code = res.statusCode;\n\n    // assign a Date to this response for the \"Cache-Control\" delta calculation\n    res.date = new Date();\n    res.parsed = parsed;\n    debug('got %o response status code', code);\n\n    // any 2xx response is a \"success\" code\n    var type = code / 100 | 0;\n\n    // check for a 3xx \"redirect\" status code\n    var location = res.headers.location;\n    if (3 == type && location) {\n      if (!opts.redirects) opts.redirects = [];\n      var redirects = opts.redirects;\n      if (redirects.length < maxRedirects) {\n        debug('got a \"redirect\" status code with Location: %o', location);\n\n        // flush this response - we're not going to use it\n        res.resume();\n\n        // hang on to this Response object for the \"redirects\" Array\n        redirects.push(res);\n        var newUri = url.resolve(parsed, location);\n        debug('resolved redirect URL: %o', newUri);\n        var left = maxRedirects - redirects.length;\n        debug('%o more redirects allowed after this one', left);\n\n        // check if redirecting to a different protocol\n        var parsedUrl = url.parse(newUri);\n        if (parsedUrl.protocol !== parsed.protocol) {\n          opts.http = parsedUrl.protocol === 'https:' ? https : undefined;\n        }\n        return get(parsedUrl, opts, fn);\n      }\n    }\n\n    // if we didn't get a 2xx \"success\" status code, then create an Error object\n    if (2 != type) {\n      var err;\n      if (304 == code) {\n        err = new NotModifiedError();\n      } else if (404 == code) {\n        err = new NotFoundError();\n      } else {\n        // other HTTP-level error\n        var message = http.STATUS_CODES[code];\n        err = new Error(message);\n        err.statusCode = code;\n        err.code = code;\n      }\n      res.resume();\n      return fn(err);\n    }\n    if (opts.redirects) {\n      // store a reference to the \"redirects\" Array on the Response object so that\n      // they can be inspected during a subsequent call to GET the same URI\n      res.redirects = opts.redirects;\n    }\n    fn(null, res);\n  }\n}\n\n/**\n * Returns `true` if the provided cache's \"freshness\" is valid. That is, either\n * the Cache-Control header or Expires header values are still within the allowed\n * time period.\n *\n * @return {Boolean}\n * @api private\n */\n\nfunction isFresh(cache) {\n  var cacheControl = cache.headers['cache-control'];\n  var expires = cache.headers.expires;\n  var fresh;\n  if (cacheControl) {\n    // for Cache-Control rules, see: http://www.mnot.net/cache_docs/#CACHE-CONTROL\n    debug('Cache-Control: %o', cacheControl);\n    var parts = cacheControl.split(/,\\s*?\\b/);\n    for (var i = 0; i < parts.length; i++) {\n      var part = parts[i];\n      var subparts = part.split('=');\n      var name = subparts[0];\n      switch (name) {\n        case 'max-age':\n          var val = +subparts[1];\n          expires = new Date(+cache.date + val * 1000);\n          fresh = new Date() < expires;\n          if (fresh) debug('cache is \"fresh\" due to previous %o Cache-Control param', part);\n          return fresh;\n        case 'must-revalidate':\n          // XXX: what we supposed to do here?\n          break;\n        case 'no-cache':\n        case 'no-store':\n          debug('cache is \"stale\" due to explicit %o Cache-Control param', name);\n          return false;\n      }\n    }\n  } else if (expires) {\n    // for Expires rules, see: http://www.mnot.net/cache_docs/#EXPIRES\n    debug('Expires: %o', expires);\n    fresh = new Date() < new Date(expires);\n    if (fresh) debug('cache is \"fresh\" due to previous Expires response header');\n    return fresh;\n  }\n  return false;\n}\n\n/**\n * Attempts to return a previous Response object from a previous GET call to the\n * same URI.\n *\n * @api private\n */\n\nfunction getCache(parsed, cache) {\n  if (!cache) return;\n  var href = parsed.href;\n  if (cache.parsed.href == href) {\n    return cache;\n  }\n  var redirects = cache.redirects;\n  if (redirects) {\n    for (var i = 0; i < redirects.length; i++) {\n      var c = getCache(parsed, redirects[i]);\n      if (c) return c;\n    }\n  }\n}","map":{"version":3,"names":["url","require","http","https","extend","NotFoundError","NotModifiedError","debug","module","exports","get","parsed","opts","fn","href","cache","getCache","maxRedirects","hasOwnProperty","isFresh","location","headers","type","statusCode","Error","mod","options","lastModified","etag","req","once","onerror","onresponse","err","stack","res","code","date","Date","redirects","length","resume","push","newUri","resolve","left","parsedUrl","parse","protocol","undefined","message","STATUS_CODES","cacheControl","expires","fresh","parts","split","i","part","subparts","name","val","c"],"sources":["/Users/sathyamurthyt/Documents/Ai-forms/form-wizard/node_modules/get-uri/http.js"],"sourcesContent":["\n/**\n * Module dependencies.\n */\n\nvar url = require('url');\nvar http = require('http');\nvar https = require('https');\nvar extend = require('extend');\nvar NotFoundError = require('./notfound');\nvar NotModifiedError = require('./notmodified');\nvar debug = require('debug')('get-uri:http');\n\n/**\n * Module exports.\n */\n\nmodule.exports = get;\n\n/**\n * Returns a Readable stream from an \"http:\" URI.\n *\n * @api protected\n */\n\nfunction get (parsed, opts, fn) {\n  debug('GET %o', parsed.href);\n\n  var cache = getCache(parsed, opts.cache);\n\n  // 5 redirects allowed by default\n  var maxRedirects = opts.hasOwnProperty('maxRedirects') ? opts.maxRedirects : 5;\n  debug('allowing %o max redirects', maxRedirects);\n\n  // first check the previous Expires and/or Cache-Control headers\n  // of a previous response if a `cache` was provided\n  if (cache && isFresh(cache)) {\n\n    // check for a 3xx \"redirect\" status code on the previous cache\n    var location = cache.headers.location;\n    var type = (cache.statusCode / 100 | 0);\n    if (3 == type && location) {\n      debug('cached redirect');\n      fn(new Error('TODO: implement cached redirects!'));\n    } else {\n      // otherwise we assume that it's the destination endpoint,\n      // since there's nowhere else to redirect to\n      fn(new NotModifiedError());\n    }\n    return;\n  }\n\n  var mod;\n  if (opts.http) {\n    // the `https` module passed in from the \"http.js\" file\n    mod = opts.http;\n    debug('using secure `https` core module');\n  } else {\n    mod = http;\n    debug('using `http` core module');\n  }\n\n  var options = extend({}, opts, parsed);\n\n  // add \"cache validation\" headers if a `cache` was provided\n  if (cache) {\n    if (!options.headers) options.headers = {};\n\n    var lastModified = cache.headers['last-modified'];\n    if (lastModified != null) {\n      options.headers['If-Modified-Since'] = lastModified;\n      debug('added \"If-Modified-Since\" request header: %o', lastModified);\n    }\n\n    var etag = cache.headers.etag;\n    if (etag != null) {\n      options.headers['If-None-Match'] = etag;\n      debug('added \"If-None-Match\" request header: %o', etag);\n    }\n  }\n\n  var req = mod.get(options);\n  req.once('error', onerror);\n  req.once('response', onresponse);\n\n  // http.ClientRequest \"error\" event handler\n  function onerror (err) {\n    debug('http.ClientRequest \"error\" event: %o', err.stack || err);\n    fn(err);\n  }\n\n  // http.ClientRequest \"response\" event handler\n  function onresponse (res) {\n    var code = res.statusCode;\n\n    // assign a Date to this response for the \"Cache-Control\" delta calculation\n    res.date = new Date();\n    res.parsed = parsed;\n\n    debug('got %o response status code', code);\n\n    // any 2xx response is a \"success\" code\n    var type = (code / 100 | 0);\n\n    // check for a 3xx \"redirect\" status code\n    var location = res.headers.location;\n    if (3 == type && location) {\n      if (!opts.redirects) opts.redirects = [];\n      var redirects = opts.redirects;\n\n      if (redirects.length < maxRedirects) {\n        debug('got a \"redirect\" status code with Location: %o', location);\n\n        // flush this response - we're not going to use it\n        res.resume();\n\n        // hang on to this Response object for the \"redirects\" Array\n        redirects.push(res);\n\n        var newUri = url.resolve(parsed, location);\n        debug('resolved redirect URL: %o', newUri);\n\n        var left = maxRedirects - redirects.length;\n        debug('%o more redirects allowed after this one', left);\n\n        // check if redirecting to a different protocol\n        var parsedUrl = url.parse(newUri);\n        if (parsedUrl.protocol !== parsed.protocol) {\n          opts.http = parsedUrl.protocol === 'https:' ? https : undefined;\n        }\n\n        return get(parsedUrl, opts, fn);\n      }\n    }\n\n    // if we didn't get a 2xx \"success\" status code, then create an Error object\n    if (2 != type) {\n      var err;\n      if (304 == code) {\n        err = new NotModifiedError();\n      } else if (404 == code) {\n        err = new NotFoundError();\n      } else {\n        // other HTTP-level error\n        var message = http.STATUS_CODES[code];\n        err = new Error(message);\n        err.statusCode = code;\n        err.code = code;\n      }\n\n      res.resume();\n      return fn(err);\n    }\n\n    if (opts.redirects) {\n      // store a reference to the \"redirects\" Array on the Response object so that\n      // they can be inspected during a subsequent call to GET the same URI\n      res.redirects = opts.redirects;\n    }\n\n    fn(null, res);\n  }\n}\n\n/**\n * Returns `true` if the provided cache's \"freshness\" is valid. That is, either\n * the Cache-Control header or Expires header values are still within the allowed\n * time period.\n *\n * @return {Boolean}\n * @api private\n */\n\nfunction isFresh (cache) {\n  var cacheControl = cache.headers['cache-control'];\n  var expires = cache.headers.expires;\n  var fresh;\n\n  if (cacheControl) {\n    // for Cache-Control rules, see: http://www.mnot.net/cache_docs/#CACHE-CONTROL\n    debug('Cache-Control: %o', cacheControl);\n\n    var parts = cacheControl.split(/,\\s*?\\b/);\n    for (var i = 0; i < parts.length; i++) {\n      var part = parts[i];\n      var subparts = part.split('=');\n      var name = subparts[0];\n      switch (name) {\n        case 'max-age':\n          var val = +subparts[1];\n          expires = new Date(+cache.date + (val * 1000));\n          fresh = new Date() < expires;\n          if (fresh) debug('cache is \"fresh\" due to previous %o Cache-Control param', part);\n          return fresh;\n        case 'must-revalidate':\n          // XXX: what we supposed to do here?\n          break;\n        case 'no-cache':\n        case 'no-store':\n          debug('cache is \"stale\" due to explicit %o Cache-Control param', name);\n          return false;\n      }\n    }\n\n  } else if (expires) {\n    // for Expires rules, see: http://www.mnot.net/cache_docs/#EXPIRES\n    debug('Expires: %o', expires);\n\n    fresh = new Date() < new Date(expires);\n    if (fresh) debug('cache is \"fresh\" due to previous Expires response header');\n    return fresh;\n  }\n\n  return false;\n}\n\n/**\n * Attempts to return a previous Response object from a previous GET call to the\n * same URI.\n *\n * @api private\n */\n\nfunction getCache (parsed, cache) {\n  if (!cache) return;\n  var href = parsed.href;\n  if (cache.parsed.href == href) {\n    return cache;\n  }\n  var redirects = cache.redirects;\n  if (redirects) {\n    for (var i = 0; i < redirects.length; i++) {\n      var c = getCache(parsed, redirects[i]);\n      if (c) return c;\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}