{"ast":null,"code":"'use strict';\n\n/**\n * Module dependencies.\n */\nvar parse = require('url').parse;\nvar debug = require('debug')('get-uri');\n\n/**\n * Module exports.\n */\n\nmodule.exports = exports = getUri;\n\n/**\n * Supported \"protocols\".\n */\n\nexports.protocols = {\n  data: require('./data'),\n  file: require('./file'),\n  ftp: require('./ftp'),\n  http: require('./http'),\n  https: require('./https')\n};\n\n/**\n * Async function that returns a `stream.Readable` instance to the\n * callback function that will output the contents of the given URI.\n *\n * For caching purposes, you can pass in a `stream` instance from a previous\n * `getUri()` call as a `cache: stream` option, and if the destination has\n * not changed since the last time the endpoint was retreived then the callback\n * will be invoked with an Error object with `code` set to \"ENOTMODIFIED\" and\n * `null` for the \"stream\" instance argument. In this case, you can skip\n * retreiving the file again and continue to use the previous payload.\n *\n * @param {String} uri URI to retrieve\n * @param {Object} opts optional \"options\" object\n * @param {Function} fn callback function\n * @api public\n */\n\nfunction getUri(uri, opts, fn) {\n  debug('getUri(%o)', uri);\n  if ('function' == typeof opts) {\n    fn = opts;\n    opts = null;\n  }\n  if ('function' != typeof fn) {\n    throw new TypeError('a callback function must be provided');\n  }\n  if (!uri) return fn(new TypeError('must pass in a URI to \"get\"'));\n  var parsed = parse(uri);\n  var protocol = parsed.protocol;\n  if (!protocol) return fn(new TypeError('URI does not contain a protocol: ' + uri));\n\n  // strip trailing :\n  protocol = protocol.replace(/\\:$/, '');\n  var getter = exports.protocols[protocol];\n  if ('function' != typeof getter) return fn(new TypeError('unsupported protocol \"' + protocol + '\" specified in URI: ' + uri));\n  getter(parsed, opts || {}, fn);\n}","map":{"version":3,"names":["parse","require","debug","module","exports","getUri","protocols","data","file","ftp","http","https","uri","opts","fn","TypeError","parsed","protocol","replace","getter"],"sources":["/Users/sathyamurthyt/Documents/Ai-forms/form-wizard/node_modules/get-uri/index.js"],"sourcesContent":["'use strict';\n\n/**\n * Module dependencies.\n */\n\nvar parse = require('url').parse;\nvar debug = require('debug')('get-uri');\n\n/**\n * Module exports.\n */\n\nmodule.exports = exports = getUri;\n\n/**\n * Supported \"protocols\".\n */\n\nexports.protocols = {\n  data: require('./data'),\n  file: require('./file'),\n  ftp: require('./ftp'),\n  http: require('./http'),\n  https: require('./https')\n};\n\n/**\n * Async function that returns a `stream.Readable` instance to the\n * callback function that will output the contents of the given URI.\n *\n * For caching purposes, you can pass in a `stream` instance from a previous\n * `getUri()` call as a `cache: stream` option, and if the destination has\n * not changed since the last time the endpoint was retreived then the callback\n * will be invoked with an Error object with `code` set to \"ENOTMODIFIED\" and\n * `null` for the \"stream\" instance argument. In this case, you can skip\n * retreiving the file again and continue to use the previous payload.\n *\n * @param {String} uri URI to retrieve\n * @param {Object} opts optional \"options\" object\n * @param {Function} fn callback function\n * @api public\n */\n\nfunction getUri (uri, opts, fn) {\n  debug('getUri(%o)', uri);\n\n  if ('function' == typeof opts) {\n    fn = opts;\n    opts = null;\n  }\n  if ('function' != typeof fn) {\n    throw new TypeError('a callback function must be provided');\n  }\n\n  if (!uri) return fn(new TypeError('must pass in a URI to \"get\"'));\n\n  var parsed = parse(uri);\n  var protocol = parsed.protocol;\n  if (!protocol) return fn(new TypeError('URI does not contain a protocol: ' + uri));\n\n  // strip trailing :\n  protocol = protocol.replace(/\\:$/, '');\n\n  var getter = exports.protocols[protocol];\n\n  if ('function' != typeof getter)\n    return fn(new TypeError('unsupported protocol \"' + protocol + '\" specified in URI: ' + uri));\n\n  getter(parsed, opts || {}, fn);\n}\n"],"mappings":"AAAA,YAAY;;AAEZ;AACA;AACA;AAEA,IAAIA,KAAK,GAAGC,OAAO,CAAC,KAAK,CAAC,CAACD,KAAK;AAChC,IAAIE,KAAK,GAAGD,OAAO,CAAC,OAAO,CAAC,CAAC,SAAS,CAAC;;AAEvC;AACA;AACA;;AAEAE,MAAM,CAACC,OAAO,GAAGA,OAAO,GAAGC,MAAM;;AAEjC;AACA;AACA;;AAEAD,OAAO,CAACE,SAAS,GAAG;EAClBC,IAAI,EAAEN,OAAO,CAAC,QAAQ,CAAC;EACvBO,IAAI,EAAEP,OAAO,CAAC,QAAQ,CAAC;EACvBQ,GAAG,EAAER,OAAO,CAAC,OAAO,CAAC;EACrBS,IAAI,EAAET,OAAO,CAAC,QAAQ,CAAC;EACvBU,KAAK,EAAEV,OAAO,CAAC,SAAS;AAC1B,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASI,MAAMA,CAAEO,GAAG,EAAEC,IAAI,EAAEC,EAAE,EAAE;EAC9BZ,KAAK,CAAC,YAAY,EAAEU,GAAG,CAAC;EAExB,IAAI,UAAU,IAAI,OAAOC,IAAI,EAAE;IAC7BC,EAAE,GAAGD,IAAI;IACTA,IAAI,GAAG,IAAI;EACb;EACA,IAAI,UAAU,IAAI,OAAOC,EAAE,EAAE;IAC3B,MAAM,IAAIC,SAAS,CAAC,sCAAsC,CAAC;EAC7D;EAEA,IAAI,CAACH,GAAG,EAAE,OAAOE,EAAE,CAAC,IAAIC,SAAS,CAAC,6BAA6B,CAAC,CAAC;EAEjE,IAAIC,MAAM,GAAGhB,KAAK,CAACY,GAAG,CAAC;EACvB,IAAIK,QAAQ,GAAGD,MAAM,CAACC,QAAQ;EAC9B,IAAI,CAACA,QAAQ,EAAE,OAAOH,EAAE,CAAC,IAAIC,SAAS,CAAC,mCAAmC,GAAGH,GAAG,CAAC,CAAC;;EAElF;EACAK,QAAQ,GAAGA,QAAQ,CAACC,OAAO,CAAC,KAAK,EAAE,EAAE,CAAC;EAEtC,IAAIC,MAAM,GAAGf,OAAO,CAACE,SAAS,CAACW,QAAQ,CAAC;EAExC,IAAI,UAAU,IAAI,OAAOE,MAAM,EAC7B,OAAOL,EAAE,CAAC,IAAIC,SAAS,CAAC,wBAAwB,GAAGE,QAAQ,GAAG,sBAAsB,GAAGL,GAAG,CAAC,CAAC;EAE9FO,MAAM,CAACH,MAAM,EAAEH,IAAI,IAAI,CAAC,CAAC,EAAEC,EAAE,CAAC;AAChC","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}